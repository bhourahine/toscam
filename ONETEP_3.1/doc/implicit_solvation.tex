\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,lmargin=3cm,rmargin=3cm}
\usepackage{amstext}

\makeatletter
\newcommand{\lyxmathsym}[1]{\ifmmode\begingroup\def\b@ld{bold}
  \text{\ifx\math@version\b@ld\bfseries\fi#1}\endgroup\else#1\fi}
\makeatother

\usepackage{babel}

\begin{document}

\title{Implicit solvation in ONETEP}


\author{Jacek Dziedzic}


\date{June 2011}

\maketitle
The recent devel branch of ONETEP has functionality for implicit solvent
calculations, if a multigrid solver is present. For the most comfortable
experience version 3.0 or later is recommended: versions prior to
that contain known bugs.


\subsection*{The model}

ONETEP includes solvation effects by defining a smooth dielectric
cavity around the solvated molecule. In contrast to PCM-based approaches,
the transition from a dielectric permittivity of 1 to the bulk value
of the solvent is smooth and not discontinuous. Thus, there is no
\textquotedblleft{}cavity surface\textquotedblright{}, strictly speaking,
but rather a thin region of space where the transition takes place.
The cavity and the transition are defined by a simple function relating
the dielectric permittivity, $\epsilon(r)$, to the electronic density,
$\rho(r)$, yielding an isodensity model. This function, defined in
{[}1, eq. 7{]} depends on three parameters \textendash{} $\epsilon_{\infty}$,
the bulk permittivity of the solvent; $\rho_{0}$, the electronic
density threshold, where the transition takes place and $\beta$,
which controls the steepness of the change in $\epsilon$. The nonhomogeneous
Poisson equation (NPE) is then solved to obtain the potential due
to the molecular density in the nonhomogeneous dielectric. 


\subsection*{The model: smeared-ions}

Because the NPE is solved for the molecular density, yielding the
molecular potential, a numerical trick termed the smeared-ion formalism
is used to reconcile this with the usual DFT way of thinking in terms
of valence-electronic and core densities separately. In this formalism
nuclear cores are modelled by narrow positive Gaussian distributions
and the usual energy terms are re-cast (cf. {[}1, Appendix{]}:
\begin{itemize}
\item the usual Hartree energy is now replaced by the molecular Hartree
energy, that is the electrostatic energy of the molecule's charge
distribution in the potential this same charge distribution generates,
in the presence of dielectric,
\item the local pseudopotential energy is corrected by an extra term that
takes the smeared-ion nature of the cores into account,
\item a constant self-interaction correction term is added to the total
energy to account for the added Gaussian distributions (each of them
self-interacts),
\item a constant non-self-interaction correction term is added to the total
energy to account for the added Gaussian distributions (they interact
with each other).
\end{itemize}
In principle, the total energy of the system is unchanged by the application
of the smeared-ion formalism, however, due to numerical inaccuracy
some discrepancies may be observed. These cancel out when calculating
energy differences between solvated and \emph{in vacuo} systems, provided
the smeared-ion formalism is used for the vacuum calculation as well.

There is one parameter to the smeared-ion formalism, $\sigma$, which
controls the width of the Gaussians placed on the ions. 

In the smeared-ion formalism the molecular Hartree energy is obtained
not in reciprocal space, like in usual ONETEP, but rather by solving
the Poisson equation (homogeneous in vacuum, nonhomogeneous in solution)
in real space, under open boundary conditions (BCs).


\subsection*{The model: open boundary conditions}

Since the (molecular) Hartree energy is calculated under open boundary
conditions, the remaining energy terms must use open BCs for consistency.
The core-core energy is evaluated by means of a direct Coulombic sum
instead of the Ewald technique. The local pseudopotential term is
calculated in real-space rather than in reciprocal space. This happens
automatically once smeared ions are turned on. All solvation calculations
require no corrections due to periodicity (in contrast to the original
model of {[}1{]}), as there is none.


\subsection*{The model: self-consistently changing cavity}

Since the dielectric cavity is determined wholly by the electronic
density, it will change shape every time the electronic density changes.
From the physical point of view this is good, since it means the density
can respond self-consistently to the polarization of the dielectric
and vice versa. From the computational point of view this is a nightmare,
because it requires extra terms in the energy gradients (cf. {[}1,
eqs. 5 and 14{]}. The accurate calculation of these terms requires
unreasonably fine grids and becomes prohibitively difficult for all
but the smallest molecules. On the other hand, neglecting these terms
while nevertheless changing the cavity shape in response to the changes
in the electronic density results in lack of convergence. There are
three proposed solutions to this dilemma. One, straightforward and
crude, consists in fixing the cavity and not allowing it to change
shape. This is realized by performing an \emph{in vacuo} calculation
first, saving the obtained density with \texttt{write\_denskern T}
and \texttt{write\_tightbox\_ngwfs T}, then performing the calculation
in solution by restarting from the saved density. In this way the
final \emph{in vacuo} density will be used to generate the cavity,
which will remain fixed for the duration of the solvated calculation.
This should yield solvation energies within several percent of the
accurate, self-consistent calculation. As the cavity remains fixed,
the difficult extra terms no longer need to be calculated. The extra
error is insignificant while the memory and CPU requirements are greatly
reduced, thus this is the proposed solution. Note that this is still
a self-consistent process (the necessary terms are included in the
Hamiltonian), only the cavity is kept fixed.

The second solution, about twice as accurate and twice as awkward,
is to employ what we've termed quasi-self-consistency. A fully converged
\emph{in vacuo} calculation is performed similarly to the first approach.
Again, the solvated calculation proceeds by means of a restart and
uses a fixed cavity, however it is terminated after several, say 3,
steps, writing out the new density. Another restart is performed,
with the cavity being updated, as it is read from the saved files.
This is again terminated after, say 3, steps and the process is repeated
until convergence. In this way the cavity is updated in between restarts,
avoiding the need to calculate the difficult extra term. This, however,
means that the cavity is still fixed when calculating gradients, doing
line searches and so on, and the process is not strictly variational,
converging to an energy that is (expected to be) somewhere between
the approximation of approach one and the true self-consistent energy.
The awkwardness is ameliorated by the use of a script that automatically
does the restarts within one PBS job, so this does not require more
than one qsub. The third solution is to perform calculations with
the cavity self-consistently responding to changes in density (as
{[}1{]} proposes), but as mentioned earlier, this is possible only
for the smallest of molecules. Ideally, one such calculation could
be performed to assess the magnitude of the error introduced by using
one of the two simpler approaches. This error in the free energy of
solvation is expected to be less than 3-4\% percent for charged species
and less than 1\% for neutral species.


\subsection*{The model: cavitation energy}

The model in ONETEP includes the non-polar cavitation term in the
solvent-accessible surface-area (SASA) approximation, thus assuming
the cavitation energy is proportional to the surface area of the cavity,
the constant of proportionality being the (actual physical) surface
tension of the solvent, $\gamma$, and the constant term being zero.
The cavitation energy term is calculated and added automatically in
solvation calculations, provided \texttt{is\_include\_cavitation T}
is used.


\subsection*{The model: dispersion-repulsion energy}

The current model does not directly support the dispersion-repulsion
energy calculation, which might become significant especially for
larger and/or uncharged molecules. However, following {[}2{]}, it's
possible to approximate both dispersion and repulsion with the same
SASA approximation that the cavitation term uses. This is most easily
achieved by using an effective value for the solvent surface tension
coefficient instead of the actual (physical) solvent surface tension.
This allows for an approximate inclusion of dispersion and repulsion,
greatly improving results.


\subsection*{The implementation}

The NPE is solved by means of a multigrid solver. Currently ONETEP
needs to be interfaced to a 3rd party solver, for example PMG {[}3{]}.
Solving the NPE is a memory- and time-consuming process, however it's
not as bad since 2.9.3.0, as the solver is now parallelized. The memory
requirement of the solver grows cubically with the grid size, so extra
vacuum/bulk solvent is not free anymore, as soon as smeared ions are
turned on.

The solver is only able to solve the NPE to second order. To ensure
the high-order accuracy necessary for solvation calculations, a defect-correction
technique is applied, which corrects the initial solution to a higher
order by invoking the solver several times.

Another limitation of multigrid solvers is that every dimension of
the grid used in the solver must be a magic number. A number is magic
if it is of the form $k\times32+1$. Thus, there is a certain granularity
to the allowed grid sizes for the solver \textendash{} the allowed
sizes are 33, 65, 97, 129, 161, 193, 225, etc. In ONETEP the fine
grid is used in solvation. Since, by default, the fine grid is twice
as fine as the coarse grid, its dimensions are even and thus never
magic. To resolve this difficulty, only the subset of the fine grid
that is obtained by rounding its dimensions down to the nearest magic
number is used in solvation calculations. This is done automatically,
however, it's wise to realize this is happening. For example, consider
a calculation with \texttt{psinc\_spacing 0.5}, and a cubic cell 42.5
bohr in size. This will yield a coarse grid that is 85$\times$85$\times$85
and a fine grid that is 170$\times$170$\times$170. The value of
170 will be rounded down to the nearest magic number, 161 and only
the lower portion of the fine grid, 161$\times$161$\times$161 in
size, will be passed to the multigrid. ONETEP will be oblivious to
this, so it is up to you to ensure that nothing of significance (read:
density) is in the unused margin of 162-170. If your NGWFs extend
beyond that portion, you're screwed. You should aim for simulation
cells that have small margins, so that as little memory as possible
is wasted. Here, an ideal box would be 40.5 bohr in size, yielding
a fine grid 162$\times$162$\times$162 in size and the smallest margin
possible. ONETEP will warn you if the margin is suspiciously large,
but it doesn't check if there is actually any density in there.

If you choose to modify \texttt{is\_multigrid\_nlevels} (don't), the
definition of a magic number will change to $k\times2^{nlevels+1}+1$.


\subsection*{Basic directives used in solvation calculations}
\begin{itemize}
\item \texttt{is\_implicit\_solvent T/F} \textendash{} turns on/off the
implicit solvent. Default is off.
\item \texttt{is\_include\_cavitation T/F} \textendash{} turns on/off the
cavitation energy term. Default is off.
\item \texttt{is\_smeared\_ion\_rep T/F} \textendash{} turns on/off the
smeared-ion representation. Default is off. Make sure it is turned
on for both the \emph{in vacuo} and solvated calculation.
\item \texttt{is\_density\_threshold $x$} \textendash{} sets the solvation
parameter $\rho_{0}$ to $x$ (atomic units). The default is 0.00078,
as proposed in {[}1{]}.
\item \texttt{is\_solvation\_beta $x$ }\textendash{} sets the solvation
parameter $\beta$ to $x$ (no unit). The default is 1.3, as proposed
in {[}1{]}.
\item \texttt{is\_bulk\_permittivity $x$ }\textendash{} sets the solvation
parameter $\epsilon_{\infty}$ to $x$ (no unit). The default is 80.0
(suitable for water) if implicit solvent is on, and 1.0 is implicit
solvent is off.
\item \texttt{is\_solvent\_surface\_tension $x$ }\textendash{} sets the
solvation parameter $\gamma$ to $x$ (unit must be supplied). The
default is 4.7624E-5 Ha/bohr$^{2}$ (which is suitable for water,
from experiment). This, however, neglects the dispersion-repulsion
energy terms. Users are advised to use a value of 1.33859E-5 Ha/bohr$^{2}$
(\texttt{is\_solvent\_surface\_tension 0.0000133859 ha/bohr{*}{*}2}),
along with suitably changed values for \texttt{is\_solvation\_beta}
and \texttt{is\_density\_threshold }to account for dispersion-repulsion.
\item \texttt{is\_discretization\_order $x$ }\textendash{} sets the discretization
order used when solving the NPE to x (no unit). Available values are
2, 4, 6, 8, 10 and 12, the default is 8. With 2 no defect correction
is performed. Values of 4 and above employ defect correction. The
lowest values (2 and 4) are not recommended, because they offer poor
accuracy. Generally the largest value (12) will offer best accuracy,
but this has to be weighted against a likely drop in performance (higher
orders often take longer) and possibility of Gibbs-like phenomena
that may occur when high orders are used with steeply-changing dielectric
permittivity, as is the case for larger values of $\beta$. 8 or 10
is a good starting value. Results should not depend on the choice
of this parameter, but performance and multigrid convergence will.
See the troubleshooting section below for details.
\item \texttt{is\_smearing\_width $x$} \textendash{} sets the width of
the smeared-ion Gaussians, $\sigma$, to $x$ (bohr). The default
is 0.8 and should be OK for most calculations. The results should
not depend on this parameter, but only if it's within rather narrow
limits of sensibility. Too high values (anything larger than 1.0,
roughly) are seriously unphysical, as they will lead to cores whose
Gaussian tails stick out of the electronic cloud, especially in hydrogen
atoms. This is very bad, since it does not change the energy \emph{in
vacuo} (the effect of the smearing, regardless of $\sigma$, is cancelled
by the correction terms to energy), but changes the energy in solution
(by polarising the solvent differently \textendash{} in reality the
cores are screened by the electons). Too low values (anything smaller
than 0.6, roughly), on the other hand, will lead to Gaussians so thin
and tall that they will become very difficult for the multigrid solver
to treat, requiring high orders and unreasonably fine grids to obtain
multigrid convergence.
\item \texttt{is\_dielectric\_model FIX\_INITIAL/SELF\_CONSISTENT} \textendash{}
picks either the fixed cavity or the self-consistently changing cavity,
as described in \textquotedblleft{}The model: self-consistently changing
cavity\textquotedblright{}.
\item \texttt{fine\_grid\_scale $x$} \textendash{} a recent improvement
due to Nick that makes the ONETEP fine grid $x$ (no unit) times as
fine as the coarse grid, $x$ does not have to be an integer. The
solution of the NPE and associated finite-difference operations are
performed on (a subset of) the fine grid. Increasing \texttt{fine\_grid\_scale}
allows for making this grid finer without unnecessarily increasing
the kinetic energy cutoff of the calculation. The default is 2. Memory
and computational effort increase with the cube of $x$.
\end{itemize}

\subsection*{Advanced directives used in solvation calculations}

The default settings usually work fine and the advanced settings should
only be changed if you know what you're doing.
\begin{itemize}
\item \texttt{is\_multigrid\_nlevels $x$ }\textendash{} changes the number
of multigrid levels to $x$ (no unit). The default is 4. This could
affect the performance of the multigrid (but rarely does) and will
affect the granularity of the grid (which is $2^{nlevels+1}+1$).
\item \texttt{is\_multigrid\_max\_iters $x$ }\textendash{} changes the
maximum number of multigrid iterations to $x$ (no unit). The default
is 100.
\item \texttt{is\_multigrid\_error\_tol $x$} \textendash{} changes the
error tolerance used for the termination condition for the multigrid
solver to $x$ (no unit). The default is 1E-5. Smaller values (like
1E-7) will add negligible increase in accuracy at a significant computational
cost. Larger values (like 1E-3) will incur significant loss of accuracy
at a significant reduction of computational cost.
\item \texttt{is\_multigrid\_defect\_error\_tol $x$ }\textendash{} changes
the error tolerance used for the termination condition for every defect
correction iteration in the multigrid solver to $x$ (no unit). The
default is 1E-2. Smaller values (like 1E-4) may be used to help in
corner cases where the solver does not converge, but should only be
used when necessary, since they increase the computational cost. Larger
values (like 1) might decrease computational cost, but can break convergence,
especially with higher orders.
\item \texttt{is\_bc\_coarseness $x$ }\textendash{} changes the size of
the blocks into which charge is coarsened when boundary conditions
are calculated. The default is 5. Smaller values may subtly increase
accuracy, but will incur a computational cost that grows as $x\lyxmathsym{ }-3$.
This can be perfectly acceptable for smaller molecules.
\item \texttt{is\_bc\_surface\_coarseness $x$ }\textendash{} changes the
size of the surface blocks onto which charge is interpolated when
boundary conditions are calculated. The default is 1. Larger values
will improve computational cost (that grows as $x\lyxmathsym{ }-2$),
but may decrease accuracy, especially for charged molecules. If possible,
it's better to use \texttt{is\_bc\_coarseness $x$} with a larger
$x$ to speed up the calculation.
\end{itemize}

\subsection*{Expert directives used in solvation calculations}

These will only be listed here and not discussed.
\begin{itemize}
\item \texttt{is\_surface\_thickness,}
\item \texttt{is\_check\_solv\_energy\_grad,}
\item \texttt{openbc\_pspot\_finetune\_nptsx,}
\item \texttt{openbc\_pspot\_finetune\_f,}
\item \texttt{openbc\_pspot\_finetune\_alpha.}
\end{itemize}

\subsection*{Various hints for a successful start}
\begin{itemize}
\item Make sure both your vaccum and solvated calculations use smeared ions.
\item Make sure the parameters of both your vacuum and solvated calculations
are identical (box sizes, KE cutoffs, \texttt{k\_zero}, \texttt{is\_discretization\_order,
is\_smeared\_ion\_width, is\_bc\_coarseness, is\_bc\_surface\_coarseness}).
\item Choose \texttt{FIX\_INITIAL} over \texttt{SELF\_CONSISTENT} for \texttt{is\_dielectric\_model}.
\item Use an \texttt{is\_discretization\_order} of 10 and \texttt{is\_smearing\_width}
of 0.8. Specify them explicitly, as the defaults may change in the
future.
\item Do not mess with expert directives.
\item Have at least about 10 bohr of vacuum/solvent around your molecule's
NGWFs (not atomic positions) on each side of the simulation cell.
Minimize the margin discussed in \textquotedblleft{}The implementation\textquotedblright{}.
\item Always start your calculation in solution as a restart from a fully
converged \emph{in vacuo} calculation.
\end{itemize}

\subsection*{Troubleshooting: Problems, causes and solutions}
\begin{itemize}
\item \textbf{Problem}: ONETEP crashes (MPI gets killed) when evaluating
the boundary conditions or solving the NPE.\\
\textbf{Cause (1)}: You're using the Intel compiler and you forgot
to add -heap-arrays to the option list.\\
\textbf{Solution (1)}: Add -heap-arrays to the option list, recompile,
re-run.\\
\textbf{Cause (2)}: You're using the PGI compiler.\\
\textbf{Solution (2)}: Due to a bug in some versions of the PGI
compiler, which generates bad code for specification functions, the
stack is trashed in the routine buildA\_fv and out-of-bounds accesses
may be reported. Use a different compiler.\\
\textbf{Cause (3)}: You've run out of memory and the PBS scheduler
killed the calculation. Solving the NPE represents the peak memory
usage of the calculation.\\
\textbf{Solution (3)}: Increase memory on node 0 (hint: use an
orange node on Iridis3) or decrease box size or decrease grid fineness.
Consult the example 
\item \textbf{Problem}: Multigrid calculation does not converge or converges
very slowly. Multigrid iterations are the ones denoted with \textquotedblleft{}MG\textquotedblright{}
\textendash{} they consist in defect-correcting the second-order solution
to the NPE. Normally the multigrid calculation should converge within
several iterations (in vacuum) and umpteen iterations (in solution).
If it takes more iterations, the multigrid struggles to converge.
In really bad cases it will diverge, which will stop the calculation
with an error message.\\
\textbf{Cause (1)}: Charge is not correctly localized (cell is
too small).\\
\textbf{Solution (1)}: Check and fix the cell size, paying attention
to the margin between the MG grid and fine grid.\\
\textbf{Cause (2)}: Dielectric permittivity too steeply changing
on the cavity boundary for the current grid size, finite differences
struggling to approximate the changes. This is the culprit if the
calculation ran fine \emph{in vacuo} but struggles in solvent.\\
\textbf{Solution (2)}: Preferable, but painful, solution is to
make the grid finer (\texttt{fine\_grid\_scale}). Otherwise an increase
or decrease of discretization order may help (make sure it stays consistent
across your calculations, though). A parametrization with lower \texttt{is\_solvation\_beta}
and \texttt{is\_density\_threshold} will usually help (make sure it
stays consistent across your calculations, though).\\
\textbf{Cause (3)}: The smearing width is too small, making the
smeared cores too thin and tall, which is difficult for the finite
differences. This is the culprit if the calculation also struggles
\emph{in vacuo}.\\
\textbf{Solution (3)}: Increasing is\_smearing\_width will help
(but mind the consequences), if it was too small in the first place.
Increasing the discretization order will help (especially if you've
been using less than 10), but might lead to a similar problem (Cause
(2)) in solution.\\
\textbf{Cause (4)}: Too lax setting for \texttt{is\_multigrid\_defect\_error\_tol}.\\
\textbf{Solution (4)}: Decrease \texttt{is\_multigrid\_defect\_error\_tol}
to 1E-3 or less.
\item \textbf{Problem}: Calculation struggles to converge LNV or NGWFs or
does not converge at all. RMS gradient stalls.\\
\textbf{Cause (1)}: If you're using \texttt{is\_dielectric\_model
SELF\_CONSISTENT}, than this is normal, unless your grid is ridiculously
fine (you will need psinc\_spacing 0.5 and fine\_grid\_scale 4 or
better).\\
\textbf{Solution (1)}: Prefer \texttt{is\_dielectric\_model FIX\_INITIAL}.
If you definitely want\texttt{ is\_dielectric\_model SELF\_CONSISTENT},
make the grid finer and have a lot of memory on node 0.\\
\textbf{Cause (2)}: Density kernel is not converged enough.\\
\textbf{Solution (2)}: Try minit\_lnv 6 and maxit\_lnv 6 (for smaller
molecules) or \texttt{minit\_lnv 10} and \texttt{maxit\_lnv 10} (for
large molecules). 
\end{itemize}

\subsection*{What are the values for the model parameters?}

Two sets of values will be proposed here. The first one will be called
\textquotedblleft{}high-beta\textquotedblright{} parametrization.
It offers the best quality (in terms of r.m.s. error from experiment)
for both charged and neutral species. The drawback is that the high
value of $\beta$ means the multigrid convergence is poor and it often
takes a while to converge. Nevertheless, it should be the first choice.
The parameters are:

\texttt{is\_solvation\_beta 1.6}

\texttt{is\_density\_threshold 0.00055}

\texttt{is\_surface\_tension 0.0000133859 ha/bohr{*}{*}2}

The second parametrization, called \textquotedblleft{}low-beta\textquotedblright{}
should pose no problems to the multigrid solver under any circumstances.
Quality should be only marginally worse for anions and neutrals and
comparable or better for cations. The parmeters are:

\texttt{is\_solvation\_beta 1.3}

\texttt{is\_density\_threshold 0.00035}

\texttt{is\_surface\_tension 0.0000133859 ha/bohr{*}{*}2}

Both parametrizations assume \texttt{is\_bulk\_permittivity 78.54},
which is suitable for water. The model has not been tested yet on
other solvents. It should be noted that the model is deficient in
its treatment of anions, consistently underestimating the magnitude
of the solvation effect by 10-25\%. Work is ongoing to fix this, until
then a different parametrization may be used if one is only interested
in anionic species.


\subsection*{The script that makes life easier}

I wrote a PBS script that makes submitting solvation calculation easier.
First, copy the files from \textquotedblleft{}\texttt{bin}\textquotedblright{}
in the attached tarball to your \textquotedblleft{}\texttt{bin}\textquotedblright{}
on Iridis3. Then, to submit a solvation calculation, put your onetep
input files in a directory whose last component is called \textquotedblleft{}iter\_0\textquotedblright{},
such as\texttt{:}

\texttt{/local/scratch/my\_calcs/my\_molecule/iter\_0}.

Copy \texttt{pbs\_template.solvation} from one of the examples to
the \texttt{iter\_0} directory. Submit the job by typing \textquotedblleft{}\texttt{qs
pbs\_template.solvation}\textquotedblright{} (do not attempt to execute
\texttt{pbs\_template.solvation}). The script will first run the vacuum
calculation (\textquotedblleft{}\texttt{iter\_0}\textquotedblright{}),
then, after it's done, it will copy the .recpot files, the input file,
the .dkn and .tightbox\_ngwfs files to a directory called \texttt{iter\_1}.
Finally it will alter the input file in \texttt{iter\_1} to turn solvation
on and turn restarts on and will proceed to run a solvated calculation
in \texttt{iter\_1}, which is going to restart from the .dkn and .tightbox\_ngwfs
that have just been saved. If you are not using quasi-SCF, that's
it. If you are, then the process will continue, putting subsequent
quasi-SCF iterations in\texttt{ iter\_2}, \texttt{iter\_3} and so
on. To control all this, edit \texttt{pbs\_template.solvation}. There
is no need to edit \texttt{qs}.

To quickly obtain the free energies of solvation, use the '\texttt{dG\_solv}'
script provided in the \textquotedblleft{}\texttt{example\_results}\textquotedblright{}
directory in the tarball. This directory also illustrates the output
directory structure for the quasi-SCF case and the self\_consistent
case.

Check out the \textquotedblleft{}\texttt{plotgradient}\textquotedblright{}
and \textquotedblleft{}\texttt{unitconv}\textquotedblright{} scripts
as well, they may come in handy.


\subsection*{ONETEP on Iridis3}

I don't know what modules you have loaded. Just in case you're using
different ones and the \texttt{onetep} executable cannot find shared
libraries, here is to where they resolve for me, so that you can update
your \texttt{LD\_LIBRARY\_PATH} accordingly if there is need to do
so. Note that the \texttt{pbs\_template.solvation} script attempts
to load the required modules, so this scenario is unlikely.

\vskip0.2cm

\texttt{\scriptsize libmkl\_core.so => /local/software/intel/mkl/10.2.1.017/lib/em64t/libmkl\_core.so
(0x00002b9432fc4000)}{\scriptsize \par}

\texttt{\scriptsize libmkl\_intel\_lp64.so => /local/software/intel/mkl/10.2.1.017/lib/em64t/libmkl\_intel\_lp64.so
(0x00002b94331f0000)}{\scriptsize \par}

\texttt{\scriptsize libmkl\_lapack.so => /local/software/intel/mkl/10.2.1.017/lib/em64t/libmkl\_lapack.so
(0x00002b94335d2000)}{\scriptsize \par}

\texttt{\scriptsize libmkl\_sequential.so => /local/software/intel/mkl/10.2.1.017/lib/em64t/libmkl\_sequential.so
(0x00002b94342c3000)}{\scriptsize \par}

\texttt{\scriptsize libguide.so => /local/software/intel/mkl/10.2.1.017/lib/em64t/libguide.so
(0x00002b94349c3000)}{\scriptsize \par}

\texttt{\scriptsize libimf.so => /local/software/intel/Compiler/11.1/046/lib/intel64/libimf.so
(0x00002b9434b4e000)}{\scriptsize \par}

\texttt{\scriptsize libm.so.6 => /lib64/libm.so.6 (0x00000039c2800000)}{\scriptsize \par}

\texttt{\scriptsize libmpi\_f90.so.0 => /local/software/rh53/openmpi/1.3.3/intel/lib/libmpi\_f90.so.0
(0x00002b9434ec2000)}{\scriptsize \par}

\texttt{\scriptsize libmpi\_f77.so.0 => /local/software/rh53/openmpi/1.3.3/intel/lib/libmpi\_f77.so.0
(0x00002b94350c5000)}{\scriptsize \par}

\texttt{\scriptsize libmpi.so.0 => /local/software/rh53/openmpi/1.3.3/intel/lib/libmpi.so.0
(0x00002b94352fd000)}{\scriptsize \par}

\texttt{\scriptsize libopen-rte.so.0 => /local/software/rh53/openmpi/1.3.3/intel/lib/libopen-rte.so.0
(0x00002b94355cd000)}{\scriptsize \par}

\texttt{\scriptsize libopen-pal.so.0 => /local/software/rh53/openmpi/1.3.3/intel/lib/libopen-pal.so.0
(0x00002b943582d000)}{\scriptsize \par}

\texttt{\scriptsize libdl.so.2 => /lib64/libdl.so.2 (0x00000039c2400000)
libnsl.so.1 => /lib64/libnsl.so.1 (0x00000039ca400000)}{\scriptsize \par}

\texttt{\scriptsize libutil.so.1 => /lib64/libutil.so.1 (0x00000039d0c00000)}{\scriptsize \par}

\texttt{\scriptsize libpthread.so.0 => /lib64/libpthread.so.0 (0x00000039c2c00000)}{\scriptsize \par}

\texttt{\scriptsize libc.so.6 => /lib64/libc.so.6 (0x00000039c2000000)
libgcc\_s.so.1 => /lib64/libgcc\_s.so.1 (0x00000039c7400000)}{\scriptsize \par}

\texttt{\scriptsize libifport.so.5 => /local/software/intel/Compiler/11.1/046/lib/intel64/libifport.so.5
(0x00002b9435aca000)}{\scriptsize \par}

\texttt{\scriptsize libifcoremt.so.5 => /local/software/intel/Compiler/11.1/046/lib/intel64/libifcoremt.so.5
(0x00002b9435c03000)}{\scriptsize \par}

\texttt{\scriptsize libsvml.so => /local/software/intel/Compiler/11.1/046/lib/intel64/libsvml.so
(0x00002b9435ea6000)}{\scriptsize \par}

\texttt{\scriptsize libintlc.so.5 => /local/software/intel/Compiler/11.1/046/lib/intel64/libintlc.so.5
(0x00002b94360be000)}{\scriptsize \par}

\texttt{\scriptsize /lib64/ld-linux-x86-64.so.2 (0x00000039c1c00000) }{\scriptsize \par}


\subsection*{Questions?}

Questions should be directed to Jacek Dziedzic, \texttt{jd12g09 soton.ac.uk.}
\begin{thebibliography}{3}
\bibitem{key-1}Scherlis, Fattebert, Gygi, Cococcioni and Marzari,
J. Chem. Phys. \textbf{124} (2006).

\bibitem{key-2}Floris, Tomasi and Ahuir, J. Comp. Chem. \textbf{12}
(1991).

\bibitem{key-3}http://www.fetk.org/codes/pmg/index.html.
\end{thebibliography}

\end{document}
