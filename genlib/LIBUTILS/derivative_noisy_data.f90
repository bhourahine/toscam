module derivative_noise

 use matrix
 use fourier_transform_mod

 PRIVATE
 PUBLIC :: get_derivative_noise,fourier_filter_noise_

! contains
! 
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! 
!    subroutine fourier_filter_noise_(npoint,tab,vois)
!       implicit none
!       integer  :: vois,npoint
!       REAL(8)  :: tab(npoint),xx(npoint)
!        call smooft(tab,npoint,vois)
!       return
!    end subroutine
! 
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! 
! subroutine get_derivative_noise(npoint,xx,tab,nphas,popo,vois,dxdt)
! !*****************************************************************************
! !*   Smooting time series and computing successive time derivatives
! !*   npoint    : nombre de points 
! !*   nphas     : dimension of the reconstructed phase space
! !*   vois      : Smoothing window
! !*   h         : time step of the time series
! !*   dxdt(1)   : time series
! !*   dxdt(1+i) : i-th time derivative
! !*   h=0.050   : time step of sampling
! !*   vois=10   : smoothing parameter
! !*****************************************************************************
! 
!       implicit none
!       integer  :: i,k,nwin,nphas,popo,nmax,npoint,m,j,vois
!       REAL(8)  :: h,xim(nphas+popo+1),t0,dxdt(nphas+1,npoint),y,t,tab(npoint),xx(npoint)
! 
!       h=xx(2)-xx(1)
!       nwin=nphas+popo; t0=0.0
!       call smooft(tab,npoint,vois)
! 
!       do i=1,npoint-nwin
!         xim(1:nwin)=tab(i:i+nwin)
!         call deriv(popo,xim,t0,h,nwin,dxdt(:,i),nphas+1)
!         call deriv(popo,xim,t0,h,nwin,dxdt(:,i),nphas+1)
!       enddo
!       return
!       end subroutine
! 
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! 
!       subroutine deriv(nmax,x,t0,dt,n,dxdt,imax)
! !*****************************************************************************
! !*   calcul de derivees avec extrapolation polynomiale
! !*   n sera forcement impair, les derivees seront calculees en x((n+1)/2)
! !*****************************************************************************
!       implicit none
!       integer :: n,nmax,nmil,i,j,k,fac,imax
!       REAL(8) :: x(n),t0,dt,dxdt(imax)
!       REAL(8) :: t(n),coeff(n),tderiv(0:n)
! 
!       nmil=(n+1)/2
!       t(1)=t0
!       do i=2,n
!         t(i)=t(i-1)+dt
!       enddo
!       tderiv(0)=1.d00
!       do i=1,n-1
!         tderiv(i)=tderiv(i-1)*t(nmil)
!       enddo
!       call interpoly(nmax,x,t,n,coeff)
!       dxdt(1)=x(nmil)
!       do j=1,imax-1
!         dxdt(j+1)=0.d00
!         do i=j+1,n
!           fac=1
!           do k=i-j,i-1,1
!             fac=fac*k
!           enddo
!           dxdt(j+1)=dxdt(j+1)+fac*coeff(i)*tderiv(i-j-1)
!         enddo
!       enddo
!       return
!       end subroutine
! 
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! 
!       subroutine interpoly(nmax,x,t,n,coeff)
! !*****************************************************************************
! !*    interpolation polynomiale
! !*****************************************************************************
!      implicit none
!      integer n,nmax,i,j
!      REAL(8) x(n),t(n),coeff(n),smat(n,n),w(n),v(n,n),wmax,wmin,mat(n,n)
! 
!       do i=1,n
!          mat(i,1)=1.d00
!          do j=2,n
!             mat(i,j)=mat(i,j-1)*t(i)
!          enddo
!       enddo
!       call svdcmp(mat,n,n,n,n,w,v)
!       wmax=0.d00
!       do i=1,n
!          if (dabs(w(i)).gt.wmax) then
!                       wmax=dabs(w(i))
!          endif
!       enddo
!       wmin=wmax*1.d-12
!       do i=1,n
!          if (dabs(w(i)).lt.wmin) then
!                            w(i)=0.d00
!          endif
!       enddo
!       call svbksb(mat,w,v,n,n,n,n,x,coeff)
!       return
!       end subroutine
! 
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! 
!       subroutine smooft(y,n,pts)
!       REAL(8) :: y1,yn,y(n),const
!       integer :: pts
!       integer :: n,j,mmax
! 
!       mmax=n
!       const=(dble(pts)/dble(mmax))**2
!       y1=y(1); yn=y(n)
!       rn1=1.d00/dble(n-1)
!       do j=1,n
!         y(j)=y(j)-rn1*(y1*dble(n-j)+yn*dble(j-1))
!       enddo
!       if (n+1.le.mmax) then
!           do j=n+1,mmax
!             y(j)=0.d00
!           enddo
!       endif
!       m02=mmax/2
!       call realft(y,m02,1)
!       y(1)=y(1)/dble(m02)
!       fac=1.d00
!       do j=1,m02-1
!         k=2*j+1
!         if (fac.ne.0.d00) then
!             fac=dmax1(0.d00,(1.d00-const*j**2)/dble(m02))
!             y(k)=fac*y(k)
!             y(k+1)=fac*y(k+1)
!         else
!             y(k)=0.d00
!             y(k+1)=0.d00
!         endif
!       enddo
!       fac=dmax1(0.d00,(1.d00-0.25d00*dble(pts**2))/dble(m02))
!       y(2)=fac*y(2)
!       call realft(y,m02,-1)
!       do j=1,n
!         y(j)=rn1*(y1*dble(n-j)+yn*dble(j-1))+y(j)
!       enddo
!       return
!       end subroutine
! 
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!
! !*****************************************************!

end module
