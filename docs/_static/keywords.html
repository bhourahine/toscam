<table id="keywordTable" style="width:100%; text-align:left">
   <tr>
      <th>Keyword</th>
      <th>Description</th>
      <th>Default</th>
      <th>Type</th>
   </tr>
   <tr>
      <td><code>all_local_host</code></td>
      <td>=if true will send all the job on local host</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>alpha</code></td>
      <td>NCA/OCA mixing for internal self consistence</td>
      <td><code>0.3</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>always_compute_static_obs</code></td>
      <td>if true will always compute static bosonic observables</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>amp_slight_sym_breaking</code></td>
      <td>if finite it will induce a small symmetry breaking will be used for the polarized calculations in the impurity levels</td>
      <td><code>0.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>amp_slight_sym_breaking_all_iter</code></td>
      <td>if true the small symmetry breaking amp_slight_sym_breaking will be used at all DMFT iteration and not only at the first iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>assume_proj_overlap_is_diagonal</code></td>
      <td>if true the code will simplify the calculations by assuming that the projected overlap matrix is diagonal</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>atom_d_command</code></td>
      <td>name of the command to run atom_d.py</td>
      <td><code>'atom_d.py'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>average_green_ed</code></td>
      <td>if true will average the green function with the mask_sym_green_ed</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>bath_nearest_hop</code></td>
      <td>whatever bath parametrization</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>beta_ed_</code></td>
      <td>temperature for Boltzman weight. If =0. it will use the DMFT temperature</td>
      <td><code>0.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>block_size</code></td>
      <td>Block size (0 lets the routine decide)</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>cluster_dmft_green_for_self_consistence</code></td>
      <td>if true keeps the off diagonal self energy terms when sending back to onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>compute_dos</code></td>
      <td>=if true will run onetep only (1 iteration) to compute the density of states from a real frequency Solver</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>compute_ed_spin_correlation</code></td>
      <td>if true will compute spin-spin correlations within ED</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>copy_kernel</code></td>
      <td>if true will copy the kernel at each iteration to sc_dmft_full_iter</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>cpt_correct_green_out</code></td>
      <td>if true will correct the output impurity green function with the CPT formula</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>cpt_lagrange</code></td>
      <td>this is the lagrangian parameter for the weight V connecting to the large cluster</td>
      <td><code>0.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>cpt_upper_bound</code></td>
      <td>this is the upper bound on the V cpt parameters</td>
      <td><code>10000.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ctqmc_erase_status</code></td>
      <td>if true will erase status file after each CTQMC iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>cubic</code></td>
      <td>=1 for cubic harmonics</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>cutoff_dynamic</code></td>
      <td>cutoff for computing dynamical green function</td>
      <td><code>1e-08</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>cutoff_energy</code></td>
      <td>energy plane wave cutoff</td>
      <td><code>850.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>cutoff_hamilt_param</code></td>
      <td>cutoff_hamilt_param: under this param the hamiltonian parameters are considered as 0</td>
      <td><code>0.001</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>cutoff_min_lanczos_vec</code></td>
      <td>cutoff for the minimal norm of a vector obtained in Lanczos</td>
      <td><code>1e-25</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>cutoff_rvb</code></td>
      <td>cutoff under which it is considered no more as rvb state but as normal state</td>
      <td><code>0.01</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>cutoff_simp_offdiag</code></td>
      <td>if off diag elements of simp smaller than cutoff</td>
      <td><code>0.01</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>debug_mode_erase_sigma</code></td>
      <td>if true erases the self energy files</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>demax0</code></td>
      <td>max. energy of excited state to consider</td>
      <td><code>5.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>diag_bath</code></td>
      <td>takes into account only the diagonal elements of the bath</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>diag_v</code></td>
      <td>if true bath V is diagonal</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>diis_max</code></td>
      <td>number of kernel iterations kept for pullay mixing</td>
      <td><code>5</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>dimer_average_occupation</code></td>
      <td>if true the occupation will be averaged on both sites of the dimer for the double counting correction</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>dist_max</code></td>
      <td>max. error on hybridization functions</td>
      <td><code>1e-10</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>dmft_for_dimer</code></td>
      <td>if true the library treats the problem as a dimer</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>dmft_kernel_process</code></td>
      <td>1-standard dmft kernel</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>dmft_spin</code></td>
      <td>spin of the DMFT self consistence. By default doing PM calculations</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>dmft_split</code></td>
      <td>if true will split the onetep dmft interface over cpus with MPI rather than NFS</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>dmft_splitk</code></td>
      <td>if true splits the mpi onetep dmft interface in several batches each of them running different K points</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>dmft_splitk_batch</code></td>
      <td>number of cpus in each of the batch when splitting k points</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>dmft_splitkdmftall</code></td>
      <td>if true splits the mpi onetep dmft interface in several batches each of them running different K points</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>do_keldysh</code></td>
      <td>keldysh : if true will run the keldysh calculations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>do_keldysh_gbigger</code></td>
      <td>keldysh : if true will also compute G^></td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>do_not_use_opt_lanczos</code></td>
      <td>if true will not use the optimized version of the Lanczos algorithm</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>do_quench</code></td>
      <td>keldysh : if 1 will do a quench in magnetic field</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>donot_compute_holepart_spm</code></td>
      <td>if false will compute both hole and particle part of S+S-</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>double_counting_nf</code></td>
      <td>if negative</td>
      <td><code>-1.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>double_counting_with_no_average</code></td>
      <td>if true will not use the averaged U value which takes into accoung the hunds coupling rule</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>double_counting_zero_self</code></td>
      <td>if true it will impose that the self energy is zero at infinite frequency</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>double_counting_zero_self_av</code></td>
      <td>if true remove the orbital averaged Sigma(w=oo)</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>double_counting_zero_self_from_matsu</code></td>
      <td>if true the self energy estimated at w=oo for the double counting correction is taken from the matsubara self energy</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>dpmax</code></td>
      <td></td>
      <td><code>0.6</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>dpmin</code></td>
      <td></td>
      <td><code>0.05</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>dump_ground_state</code></td>
      <td>write the ground state to a file during the Lanczos process</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ed_compute_all</code></td>
      <td>if true will compute all observables within ED</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ed_compute_retarded_every_step</code></td>
      <td>if true will compute the retarded Green function at every dmft step</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ed_do_not_keep_previous_fit_param</code></td>
      <td>if true the previous ED fit will not be used for the next iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ed_frequ_max</code></td>
      <td>max ED real frequ</td>
      <td><code>10.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ed_frequ_min</code></td>
      <td>min ED real frequ</td>
      <td><code>-10.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ed_no_real_overide</code></td>
      <td>if true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ed_nsearch</code></td>
      <td>number of conjugate gradient iterations for fitting the hybridization for ED solver</td>
      <td><code>200000</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ed_num_eigenstates_print</code></td>
      <td>the number of lowest-energy eigenstates of the reduced spectral density to list in the logfile report</td>
      <td><code>16</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ed_rdelta</code></td>
      <td>small i*delta to shift off the real frequency axis</td>
      <td><code>0.0001</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ed_rdelta_frequ_eta1</code></td>
      <td>eta1</td>
      <td><code>0.002</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ed_rdelta_frequ_t</code></td>
      <td>ramp to move from 0 to eta1</td>
      <td><code>0.0003</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ed_rdelta_frequ_w0</code></td>
      <td>frequency at which we have eta1</td>
      <td><code>0.0006</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ed_real_frequ</code></td>
      <td>ed number of frequencies</td>
      <td><code>1000</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ed_real_frequ_last</code></td>
      <td>ed number of frequencies for last DMFT iter</td>
      <td><code>100</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ed_solver_compute_all_green_functions</code></td>
      <td>if true it will tell the ED solver to compute all matrix elements of the Green function</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ed_star_geom</code></td>
      <td>if true will use the so-called star geometry for the hybridization for ED solver</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>edfile</code></td>
      <td>ED-SOLVER PARAMETERS FILE</td>
      <td><code>'./ED/ED.in'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>endlambda</code></td>
      <td>NCA/OCA EndLambda</td>
      <td><code>200.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>erase_chem</code></td>
      <td>if true erases the chemical potential between different DMFT iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fast_fit</code></td>
      <td>use a faster way to obtain the fit through eigenvalue decomposition</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>first_iter_use_edinput</code></td>
      <td>start the dmft iterations with the initial bath parameters as a starting bath instead of the Delta(iw) input</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fit_all_elements_show_graphs</code></td>
      <td>if true will show the fit in agr files for all matrix elements</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fit_green</code></td>
      <td>if true ED solver will fit the Weiss Field instead of the hybridization</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fit_meth</code></td>
      <td>FITTING METHODS</td>
      <td><code>'MINIMIZE'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>fit_nw</code></td>
      <td>only consider the fit_nw matsubara frequencies for the fit</td>
      <td><code>650</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>fit_shift</code></td>
      <td>Bath fit : give the shift of the 1/(w**a+shift) fit</td>
      <td><code>0.01</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>fit_weight_power</code></td>
      <td>Bath fit : give the exponent of the 1/w**a to weight the frequencies to fit</td>
      <td><code>0.5</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>flag_all_green_func_computed</code></td>
      <td>will compute the full Green function correlations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_blank_out_green_offdiag_for_testing</code></td>
      <td>if true will blank out the off-diagonal elements of the cluster hybridization</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_blank_out_sigma_offdiag_for_testing</code></td>
      <td>if true will blank out the off-diagonal elements of the cluster self energy</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_build_correl_low_part</code></td>
      <td>build automatically the lower part of the correl mask</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_correct_eimp_spin_orbit</code></td>
      <td>if true will add a correction to the impurity level due to the spin-orbit coupling</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_donot_keep_all_files</code></td>
      <td>if true will not keep all the details and every files of the calculations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_dump_info_for_gamma_vertex</code></td>
      <td>if true will dump out the necessary files to compute Gamma (four leg vertex) for later postprocessing</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_full_ed_green</code></td>
      <td>if set to true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_get_t2c_real</code></td>
      <td>if true will try to correct the T2C matrix for the rotation with the right phases such that it reduces the imaginary part as much as possible</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_gup_is_gdn</code></td>
      <td>take care</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_idelta_two_scales_ed</code></td>
      <td>if true the ED solver will use a double energy scale for the idelta frequency dependence</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>flag_introduce_noise_in_minimization</code></td>
      <td>if yes it will introduce some noise in the minimization between 2 dmft iterations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_introduce_only_noise_in_minimization</code></td>
      <td>if yes it will start from a fresh random guess for the bath minimization at every DMFT iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_mpi_greens</code></td>
      <td>compute each green functions on a different CPU</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>flag_ncup</code></td>
      <td>compute cor hopping green function n_dn C_iup</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_symmetrize_green</code></td>
      <td>if true will symmetrize input green function</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_turn_off_dmft</code></td>
      <td>if true will not copy the DMFT kernel for the next ONETEP iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_turn_off_store</code></td>
      <td>if true does not use the store file system to speed up calculations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_use_broadening_two_scales_ed</code></td>
      <td>if >0 the ED solver will use a broadening factor which assumes two different energy scales</td>
      <td><code>-1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>flag_use_jj_basis_for_f</code></td>
      <td>if true will use the L+S j-j basis for the f orbital</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>flag_use_slater_in_ed</code></td>
      <td>if true uses Slater interaction for ED</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fmos</code></td>
      <td>if true will run a mean field solver instead of ED</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fmos_fluc</code></td>
      <td>if true takes also into account the charge fluctuations in the FMOS approximation</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fmos_hub1</code></td>
      <td>if true uses the Hubbard I solver as a fast multi-orbital solver</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fmos_hub_iter_mu</code></td>
      <td>number of iteration to impose a target density in Hubbard I solver</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>fmos_hub_range_mu</code></td>
      <td>interval to adjust the chemical potential to reach a target density in the Hubbard I solver</td>
      <td><code>0.001</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>fmos_iter</code></td>
      <td>number of mean field iterations</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>fmos_mix</code></td>
      <td>mixing for FMOS iterations</td>
      <td><code>0.3</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>fmos_use</code></td>
      <td>if true use FMOS solver instead of ED</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>followpeak</code></td>
      <td>NCA/OCA follow peak</td>
      <td><code>-1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>force_no_bcs_pairing</code></td>
      <td>if true will run the superconducting code</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>force_no_pairing</code></td>
      <td>if true kills the pairing</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>force_nupdn_basis</code></td>
      <td>Force the use of the nup ndn quantum number</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>force_pairing_from_mask</code></td>
      <td>force the use of the pairing defined in the MASK of ed_hybrid instead of relaxing all parameters</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>force_para_state</code></td>
      <td>force the paramagnetic symmetry (up/dn spin the same)</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>force_self_infty_real</code></td>
      <td>if true it will estimate the self energy at infinite frequency as a real number</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>force_singlet_state</code></td>
      <td>force the singlet state in the superconducting calculations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>force_sz_basis</code></td>
      <td>Force the use of the Sz quantum number (mandatory for SC state</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>freeze_pole_lambda</code></td>
      <td>between 0 and 1</td>
      <td><code>1.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>fully_sc</code></td>
      <td>If true will use the self energy in the energy functional in the DFT kernel/NGWF optimization</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>fully_sc_h</code></td>
      <td>if true will use the one shot Kohn Sham hamiltonian obtained by DMFT in onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>gen_cpt</code></td>
      <td>if true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>hf_average</code></td>
      <td>Hirsch Fye average over time slices</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>hf_hartree</code></td>
      <td>if true will impose the hartree shift in the self energy obtained by Quantum Monte Carlo</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>hf_krauth</code></td>
      <td>Hirsch Fye with Krauth</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>hide_errors</code></td>
      <td>this iterface will not show the list of minor errors occuring when for instance the mpi aborts</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>highest_occupancy</code></td>
      <td>highest occupancy of the atom</td>
      <td><code>12</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>hydrogenic_projectors</code></td>
      <td>if >0 will use hydrogenic projectors with given effective charge instead of atomic orbitals used by the solver</td>
      <td><code>-1.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>im_solver</code></td>
      <td>choice of the solver for matsubara calculations</td>
      <td><code>4</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>impose_no_cdw</code></td>
      <td>if true will impose that the self energy in the dimer case is not a charge density wave (symmetrize sigma at the output of ED)</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>improve_mu_conv</code></td>
      <td>if true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>input_temp_dir</code></td>
      <td>=local directory to store the atom subdirectories</td>
      <td><code>'.'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>iter_dmft</code></td>
      <td>=dmft iteration number</td>
      <td><code>-1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>iter_lin</code></td>
      <td>from 1-iter_lin the mixing is linear</td>
      <td><code>3</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>iter_restart_sc</code></td>
      <td>restart from this iter the calculation</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>iwindow</code></td>
      <td>for track_sectors</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>jhund</code></td>
      <td>Hunds coupling</td>
      <td><code>0.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>just_onetep</code></td>
      <td>=if true it will only compute the onetep part</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>keep_both_real_and_matsu_last</code></td>
      <td>if true keeps both the sigma_output in matsu and real representations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>keldysh_n</code></td>
      <td>keldysh : number of time frames</td>
      <td><code>5</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>keldysh_ortho</code></td>
      <td>keldysh : if positive number will re-orthogonalize the Lanczos vector when building the local Kryslov space for the time evolution</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>keldysh_pert_ground_sector</code></td>
      <td>if true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>keldysh_t0</code></td>
      <td>keldysh : t0</td>
      <td><code>0.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>keldysh_tmax</code></td>
      <td>keldysh : tmax</td>
      <td><code>10.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>kernel_cutoff</code></td>
      <td>cutoff for kernel truncation</td>
      <td><code>4000.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>kernelfix_only_first_iter</code></td>
      <td>if true will use kernel_fix:2 only for first DFT iter</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>kerneliter</code></td>
      <td>number of iterations for kernel updates</td>
      <td><code>4</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>kerneliterinit</code></td>
      <td>number of iterations for kernel updates</td>
      <td><code>10</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ks_shift</code></td>
      <td>if true adds the correction induced by shift of occupations in the Kernel DFT minimization where the DFT energy is introduced</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>lambda_sym_fit</code></td>
      <td>coefficient that contributes to the fitting distance for finding the AIM parameters. Basically</td>
      <td><code>0.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>last_iter_is_real</code></td>
      <td>if true and if solver is ED</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>lin_nval</code></td>
      <td>number of eigenvalues for linear inversion of GF</td>
      <td><code>40</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>lin_scaling</code></td>
      <td>if true the code will use for the DMFT part (not the kernel) a linear scaling algorithm to invert the GF</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>lin_window</code></td>
      <td>window of energy around fermi level for linear scaling inversion</td>
      <td><code>0.4</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>list_sectors</code></td>
      <td>list of sectors nup</td>
      <td><code>'list0'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>lowest_occupancy</code></td>
      <td>lowest occupancy of the atom</td>
      <td><code>2</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>mach_onetep</code></td>
      <td>name of the machine file for the GF calculation</td>
      <td><code>'machines_onetep'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>matsu_solver</code></td>
      <td>if true does not generate real axis quantities (matsubara solver)</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>max_steps</code></td>
      <td>NCA/OCA max numer of internal steps</td>
      <td><code>30</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>mcs_ctqmc</code></td>
      <td>number of MonteCarlo steps for CTQMC solver</td>
      <td><code>20000000</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>min_all_bath_param</code></td>
      <td>if /= 0 will overtake the ed_hybrid file and minimize all the bath parameters</td>
      <td><code>8</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>mixing</code></td>
      <td>DMFT mixing for Self-Energy</td>
      <td><code>0.5</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>mixing_dft_dmft</code></td>
      <td>mixing of DFT AND DMFT kernel</td>
      <td><code>0.2</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>monitor_gpu_temperature</code></td>
      <td>if true will prepare a graphic of the GPU temperature during the ONETEP+DMFT run</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>mpi_onetep_type</code></td>
      <td>if 1 will run a home made mpi</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>mu_diff</code></td>
      <td>precision (max deviation) from target density in the DMFT when the chemical potential is obtained by the Newton-Parston algorithm</td>
      <td><code>0.04</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>ncpt_approx</code></td>
      <td>this is an additional degree of approximation</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ncpt_flag_two_step_fit</code></td>
      <td>if true will do the ncpt fit in two steps : first ncpt is turned off</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ncpt_two_step</code></td>
      <td>if true always do the fits in two steps procedures</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ncpt_two_step_all_iter</code></td>
      <td>if true will enforce the two step fit for CPT at every dmft iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>ncpt_two_step_iter</code></td>
      <td>if iter_dmft_sc < ncpt_two_step_iter then the CPT ED solver will use a two step procedure to fit the hybridization</td>
      <td><code>100000</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>neigen</code></td>
      <td>number of eigenvalues to compute</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nfrequencies_dmft_dft</code></td>
      <td>number of frequencies for the DFT+DMFT calculations</td>
      <td><code>160</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ngwf_cgiter</code></td>
      <td>number of iterations for NGWF update after dmft iter</td>
      <td><code>3</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_dft_dmft_sc</code></td>
      <td>Number of mixed DFT+DMFT iteration</td>
      <td><code>5</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_dmft</code></td>
      <td>Number of DMFT iteration</td>
      <td><code>5</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_dmft_mu</code></td>
      <td>number of iterations used to adjust the chemical potential in DFT when preparing the input files for the DMFT</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_kernel_mu</code></td>
      <td>number of iterations for the Newton method to adapt the chemical potential</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_sc_dft</code></td>
      <td>Number of iteration at the DFT level</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_sc_dft_first</code></td>
      <td>number of DFT iterations for the first DFT set</td>
      <td><code>4</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_sc_dmft</code></td>
      <td>Number of iteration at the dmft level</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_search_max</code></td>
      <td>Niter_search_max = max. numb. of function calls in conjugate gradient</td>
      <td><code>100</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>niter_search_max_0</code></td>
      <td>if non zero</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nitergreenmax</code></td>
      <td>max.numb.of Lanczos iterations in Green s fct. computation</td>
      <td><code>36</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nitermax</code></td>
      <td>max. number of Lanczos iterations</td>
      <td><code>128</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nkpoints</code></td>
      <td>although onetep is Gamma only calculation</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nmatsu_ctqmc</code></td>
      <td>number of matsubara frequencies for CTQMC solver</td>
      <td><code>20</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nmatsu_ed</code></td>
      <td>number of matsubara frequencies for ED solver</td>
      <td><code>4000</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nmatsu_long</code></td>
      <td>if 0 does not have any effect</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>no_frequ_split</code></td>
      <td>if true the onetep dmft interface will not split over frequencies</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>nohole</code></td>
      <td>if true will not compute the hole part of the green function</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>nokernelupdate</code></td>
      <td>if true will not update the density kernel in the dft part</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>nomachinefile</code></td>
      <td>if true removes -machinefile from the mpi syntax</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>nproc</code></td>
      <td>=number of processors for dmft</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nproc_gpu</code></td>
      <td>number of processor for the projection of the green function part in onetep</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nproc_mpi_solver</code></td>
      <td>=number of processors (MPI type) used for DMFT solver</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nproc_onetep</code></td>
      <td>=number of processors (MPI type) for onetep</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nproc_onetep_openmp</code></td>
      <td>will run mpi for the onetep dmft interface</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nproc_onetep_openmp_</code></td>
      <td>will run mpi for the onetep dmft interface</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nproc_store</code></td>
      <td>number of cpu used to obtain the store files with onetep</td>
      <td><code>8</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nsec</code></td>
      <td>number of sectors to diagonalize</td>
      <td><code>-1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>nsec0</code></td>
      <td>If list_sectors not provided</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>ntauhf</code></td>
      <td>imaginary time discretization for HF solver</td>
      <td><code>50</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>numa</code></td>
      <td>numa avoids remote memory access in multi-socket architectures</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>oldgsfile</code></td>
      <td>OLD GS FILE</td>
      <td><code>'./ED_out/GS.raw'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>on_fly</code></td>
      <td>do not store the sparse hamiltonian matrix for the Sz case</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>onetep_only_up</code></td>
      <td>=true if onetep produces only up spin</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>onetep_spin</code></td>
      <td>spin of the ONETEP calculation (1=pm or 2=af)</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>onlygammakernel</code></td>
      <td>if true will not estimate the DFT kernel from the k-point average obtained from DMFT</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>openmp_solver</code></td>
      <td>Number of open-mp cores running for the dmft-solver</td>
      <td><code>8</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>pairing_imp_to_bath</code></td>
      <td>pairing between impurity and bath</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>paramagnetic</code></td>
      <td>=1 is paramagnetic</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>print_qc</code></td>
      <td>if true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>protect_projectors</code></td>
      <td>will make the file run.tightbox_hubbard read only</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>purify_sc</code></td>
      <td>if true uses the purifed kernel in the DFT module properties for dft+dmft</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>qq</code></td>
      <td>NCA/OCA QQ parameter for seeking out lambda</td>
      <td><code>8.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>quench_cancel_statistics</code></td>
      <td>keldysh : if true will not use the initial statistics from the modified initial hamiltonian</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>quench_mag</code></td>
      <td>keldysh : magnetic field along z axis used for the quench</td>
      <td><code>1.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>quench_orb</code></td>
      <td>keldysh : which orbital should be computed for the evolution</td>
      <td><code>-1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>quench_u</code></td>
      <td>keldysh : Coulomb repulsion used for the quench</td>
      <td><code>10.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>rankin</code></td>
      <td>=rank given as an input</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>read_cix_file</code></td>
      <td>if true will read the cix file instead of generating it</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>real_axis_only_last_step</code></td>
      <td>if true the real axis quantities obtained by the ED solver are only obtained for the last two DMFT steps</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>real_eimp_from_onetep</code></td>
      <td>condition on the quantities extracted from onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>real_eimp_from_tail</code></td>
      <td>condition on the quantities extracted from onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>real_smat_coef</code></td>
      <td>if true the S matrix (projected overlap matrix) will be enforced to be real</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>real_smat_from_onetep</code></td>
      <td>condition on the quantities extracted from onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>real_solver</code></td>
      <td>choice of the solver for real-axis calculations</td>
      <td><code>2</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>real_sproj_from_onetep</code></td>
      <td>condition on the quantities extracted from onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>restart_from_iteration_number</code></td>
      <td>restart from iteration number given here instead of starting from first iteration</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>restart_from_older_dft</code></td>
      <td>if true it will run a usual onetep+dmft calculations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>rotate_int_after_earlier_transfo</code></td>
      <td>if true will rotate the CTQMC interaction according to an earlier transformation</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>rotate_ortho_av_renorm_int</code></td>
      <td>if true will use averaged renormalization induced by the non orthogonal basis set</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>rotate_to_ortho_basis</code></td>
      <td>if true the code will perform a rotation to the orthogonal basis back and forth</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>rotation_green_function</code></td>
      <td>if true the code will rotate the Green Function such that it is diagonal</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>rotation_scheme</code></td>
      <td>if 1 rotates the green function according to the occupation matrix</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>rotation_scheme_pm</code></td>
      <td>if true will use the same rotation for spin up and spin dn</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>rotation_scheme_read_write</code></td>
      <td>if true and rotation==4</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>sandwitch_embedding</code></td>
      <td>if true it will generate both left and right embedding files</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>save_atoms_at_each_steps</code></td>
      <td>if true TOSCAM will save the atoms directories at every self consistent iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>sc_start_from_previous_run</code></td>
      <td>if true starts from a previous run and reads tightbox and dkn files</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>scan_full_nup_ndn</code></td>
      <td>if true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>search_step</code></td>
      <td>small step in search direction</td>
      <td><code>0.0001</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>second_order_correction_to_eimp</code></td>
      <td>if true includes second order corrections to Eimp</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>sites_ed</code></td>
      <td>number of sites in the bath for ED solver</td>
      <td><code>5</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>size2in</code></td>
      <td>=size2 given as an input</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>slater_inter_cutoff</code></td>
      <td>the cutoff under which the Slater terms are not taken into account in the Hamiltonian matrix</td>
      <td><code>1e-05</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>spin_breaking_amp</code></td>
      <td>amplitude of the initial symmetry breaking for AF state</td>
      <td><code>0.05</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>spin_breaking_iter</code></td>
      <td>number of iterations where the symmetry breaking is applied on the impurity energy levels</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>spin_orbit</code></td>
      <td>spin-orbit coupling</td>
      <td><code>0.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>split_onetep</code></td>
      <td>=asynchronous calls to onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>start_from_an_old_sim</code></td>
      <td>=if true start from an old calculation</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>start_from_old_gs</code></td>
      <td>START FROM OLD GS</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>start_para</code></td>
      <td>force starting the first iteration fit from a paramagnetic state</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>startlambda</code></td>
      <td>NCA/OCA StartLambda</td>
      <td><code>-300.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>store_sig_in_scratch</code></td>
      <td>if true the sigma_output files will be copied to local scratch when running onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>sum_over_k_dft</code></td>
      <td>if true the code is expecting that a summation over k-points was done at the DFT level</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>tail_linear_scaling</code></td>
      <td>tail to match the free GF</td>
      <td><code>-1.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>tolerance</code></td>
      <td>Lanczos convergence tolerance</td>
      <td><code>1e-12</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>tough_converge</code></td>
      <td>if true will use some flags in onetep to help fixing the density kernel</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>track_sectors</code></td>
      <td>if true the code is tracking the ground state sector along the DMFT iterations</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>uniform_sigma</code></td>
      <td>=true sigma is imposed as spatially uniform</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_custom_command_for_atomd</code></td>
      <td>if true uses custom command line for atom_d.py instead of the default</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_eimp_from_onetep</code></td>
      <td>if true will use the analytical formula for eimp obtained from Onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_eimp_from_onetep_with_sigma_cor</code></td>
      <td>if true</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_input_delta</code></td>
      <td>if true will use the input hybridization to compute the self energy in the ED solver</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_precomputed_slater_matrix</code></td>
      <td>if true will use a precomputed Hamiltonian matrix for the Slater interaction</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_previous_dmft_files</code></td>
      <td>if true the code will use the previous dmft files for the next iteration</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_same_self_energy</code></td>
      <td>if true always copy the self energy from the 1st iteration back</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_simp_from_onetep</code></td>
      <td>if true will use the analytical formula for simp obtained from Onetep</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_simp_from_onetep_for_ortho</code></td>
      <td>uses the Simp matrix obtained by onetep to compute the transformations to non-ortho basis</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>use_transpose_trick_mpi</code></td>
      <td>each cpu keeps only a chunk of the lanczos vector in memory</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>uu</code></td>
      <td>Coulomb repulsion</td>
      <td><code>5.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>verbose_graph</code></td>
      <td>plot hybridization fit at each step of the minimization</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>verysilent</code></td>
      <td>if true the solver will be as silent and interact as little as possible with the local directory and outputs</td>
      <td><code>True</code></td>
      <td>boolean</td>
   </tr>
   <tr>
      <td><code>weight_expo</code></td>
      <td>exponent power of the fitting difference |a-b|^weight_exop</td>
      <td><code>2.0</code></td>
      <td>float</td>
   </tr>
   <tr>
      <td><code>which_lanczos</code></td>
      <td>NORMAL</td>
      <td><code>'NORMAL'</code></td>
      <td>string</td>
   </tr>
   <tr>
      <td><code>window_hybrid</code></td>
      <td>window (left) of matsubara frequencies to fit the hybridization</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>window_hybrid2</code></td>
      <td>window (right) of matsubara frequencies to fit the hybridization</td>
      <td><code>0</code></td>
      <td>integer</td>
   </tr>
   <tr>
      <td><code>window_weight</code></td>
      <td>ratio weight point inside window over point outside window</td>
      <td><code>1</code></td>
      <td>integer</td>
   </tr>
</table>