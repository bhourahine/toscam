! -*- mode: F90 ; mode: font-lock ; column-number-mode: true -*-
!-----------------------------------------------------------------------!
!                                                                       !
! Chebyshev representation module                                       !
!                                                                       !
! Written by Jacek Dziedzic in January 2012                             !
!                                                                       !
!-----------------------------------------------------------------------!
!                                                                       !
! This module implements expansion of functions into Chebyshev          !
! polynomials. The expansions can then be easily and efficiently        !
! integrated. This is especially handy for integrals of products --     !
! in order to obtain \int f1_i(x) f2_j(x) dx for i=1..M, j=1..N,        !
! it suffices to expand f1_i(x) for i=1..M and f2_j(x) for j=1..N       !
! (at a cost of O(M+N)), followed by integrating the product of the     !
! expansions, which, although still O(M*N), has a much smaller prefactor!
! as products of Chebyshev polynomials can be accurately and efficiently!
! integrated.                                                           !
!                                                                       !
! The module currently implements this for 1D integrals and for         !
! 3D integrals over a sphere. The expansion is performed on a given     !
! number of interval to prevent Runge's phenomenon that plagues         !
! high-order expansions. Thus it is possible to expand a function over, !
! say, 10 intervals with 8th order Chebyshev polynomials.               !
!                                                                       !
!-----------------------------------------------------------------------!


module chebyshev_rep

  use constants, only: DP
  use utils, only: utils_trace_in, utils_trace_out

  implicit none
  private

  ! Public types
  public :: SPHERE_NODES
  public :: SPHERE_COEFFS
  public :: HANDLE_SET

  ! Public subroutines

  ! --- single-interval, 1D expansion ---
  public :: cheb_gen_nodes_1D
  public :: cheb_expansion_1D
  public :: cheb_int_1D
  public :: cheb_int_product_1D

  ! --- many-interval (piecewise), 1D expansion ---
  public :: cheb_gen_nodes_piecewise_1D
  public :: cheb_expansion_piecewise_1D
  public :: cheb_int_piecewise_1D
  public :: cheb_int_product_piecewise_1D

  ! --- 3D expansion over a sphere ---
  public :: cheb_gen_nodes_for_sphere
  public :: cheb_expansion_for_sphere
  public :: cheb_int_sphere
  public :: cheb_int_product_sphere

  ! --- Allocation and deallocation of coefficients ---
  public :: cheb_alloc_coeffs
  public :: cheb_dealloc_coeffs

  ! --- Interprocessor communication of coefficients ---
  public :: cheb_send_coeffs_initiate
  public :: cheb_recv_coeffs_initiate
  public :: cheb_test_completion

  ! ---------------------------------------------------------------------------

  ! Stores ranges of component integrals in a 3D sphere expansion
  type SPHERE_RANGES
     integer :: n_stripes
     real(kind=DP) :: zmin
     real(kind=DP) :: zmax
     real(kind=DP), allocatable :: ymin(:)
     real(kind=DP), allocatable :: ymax(:)
     real(kind=DP), allocatable :: xmin(:,:)
     real(kind=DP), allocatable :: xmax(:,:)
  end type SPHERE_RANGES

  ! Stores Chebyshev nodes in a 3D sphere expansion
  type SPHERE_NODES
     integer :: n_points_total
     type(SPHERE_RANGES) :: sph_ranges
     real(kind=DP), allocatable :: znodes(:)
     real(kind=DP), allocatable :: ynodes(:,:)
     real(kind=DP), allocatable :: xnodes(:,:,:)
  end type SPHERE_NODES

  ! Stores Chebyshev expansion coefficients for a 3D sphere expansion
  ! NB, any additions to this structure require updates to
  !     cheb_send_coeffs_initiate and cheb_recv_coeffs_initiate, and updating
  !     n_variables_in_sphere_coeffs
  type SPHERE_COEFFS
     integer :: n_intervals
     integer :: order
     real(kind=DP), allocatable :: zcoeffs(:)
     real(kind=DP), allocatable :: ycoeffs(:,:)    ! currently unused
     real(kind=DP), allocatable :: xcoeffs(:,:,:)  ! currently unused
  end type SPHERE_COEFFS
  integer, parameter :: n_variables_in_sphere_coeffs = 5

  ! An opaque type for testing for completion of cheb_*_coeffs_initiate
  type HANDLE_SET
     integer :: handles(1:n_variables_in_sphere_coeffs)
  end type

  integer, parameter :: CHEB_ELEMENT_TAG = 900 ! Internal
  
  integer, parameter :: max_cheb_order = 40
  real(kind=DP) :: cheb_integrals(max_cheb_order)

  ! Table of integrals of (ChebyshevT[n,1] - ChebyshevT[n,-1])
  DATA cheb_integrals(:) / &
       2.0000000000000000000000000_DP,   0.0_DP, &
      -0.6666666666666666666666667,      0.0_DP, &
      -0.13333333333333333333333333_DP,  0.0_DP, &
      -0.05714285714285714285714286,     0.0_DP, &
      -0.03174603174603174603174603_DP,  0.0_DP, &
      -0.02020202020202020202020202,     0.0_DP, &
      -0.01398601398601398601398601_DP,  0.0_DP, &
      -0.01025641025641025641025641,     0.0_DP, &
      -0.007843137254901960784313725_DP, 0.0_DP, &
      -0.006191950464396284829721362,    0.0_DP, &
      -0.005012531328320802005012531_DP, 0.0_DP, &
      -0.004140786749482401656314700,    0.0_DP, &
      -0.003478260869565217391304348_DP, 0.0_DP, &
      -0.002962962962962962962962963,    0.0_DP, &
      -0.002554278416347381864623244_DP, 0.0_DP, &
      -0.002224694104560622914349277,    0.0_DP, &
      -0.001955034213098729227761486_DP, 0.0_DP, &
      -0.001731601731601731601731602,    0.0_DP, &
      -0.001544401544401544401544402_DP, 0.0_DP, &
      -0.001386001386001386001386001,    0.0_DP /

  ! jd: Let I_nm(x) = \int ChebyshevT[n,x] * ChebyshevT[m,x] dx
  !     The following is a table of I_nm(1) - I_nm(-1) for all n, m in [1, 40].
  !
  !     There are 35 digits of precision in case these subroutines are ever
  !     ported to quad precision.
  !
  !     It can be obtained by first running the following code in Mathematica
  !
  !  IntOfChebyshevT[n_, xx_] := ChebIntegralTable[[n + 1]] /. x -> xx
  !  IntOfChebyshevTProduct[n_, m_, xx_] := 
  !       ChebProductIntegralTable[[n + 1]][[m + 1]] /. x -> xx
  !  tabmax = 40;
  !  ChebIntegralTable = {};
  !  ChebProductIntegralTable = Table[I, {i, 1, tabmax}, {j, 1, tabmax}];
  !  IntOfChebyshevTProductLookup = 
  !       Table[I, {i, 1, tabmax}, {j, 1, tabmax}];
  !  For[n = 0, n < tabmax,
  !    AppendTo[ChebIntegralTable, Integrate[ChebyshevT[n, x], x]];
  !    AppendTo[ChebSquaredIntegralTable, 
  !         Integrate[ChebyshevT[n, x]^2, x]];
  !    For[m = 0, m < tabmax,
  !      ChebProductIntegralTable[[n + 1]][[m + 1]] = 
  !           Integrate[ChebyshevT[n, x]*ChebyshevT[m, x], x];
  !      IntOfChebyshevTProductLookup[[n + 1]][[m + 1]] = 
  !           IntOfChebyshevTProduct[n,m,1] - IntOfChebyshevTProduct[n,m,-1]; 
  !      m++;
  !    ];
  !    n++;
  !  ]
  !
  ! The output should then be saved to coeffs.txt and parsed with
  !
  ! cat coeffs.txt | sed -e "s/}}/_DP/" -e "s/{//g" -e "s/}//g" -e "s/,/_DP/g" \
  !                      -e "s/ _DP//" -e "s/\\\\//g" -e "s/_DP/_DP, /g" \
  !                | tr "," "\n" | grep DP | sed -r "s/^[ \t]*//" \
  !                | sed -r "s/^0_DP/0.0_DP/g" | sed "s/_DP/_DP, \&/g"
  real(kind=DP) :: cheb_product_integrals(max_cheb_order, max_cheb_order)

  DATA cheb_product_integrals(:,:) / &
       & 2.00000, &
       & 0.0, &
       & -0.6666, &
       & 0.0, &
       & -0.1333, &
       & 0.0, &
       & -0.0571, &
       & 0.0, &
       & -0.0317, &
       & 0.0, &
       & -0.0202, &
       & 0.0, &
       & -0.0139, &
       & 0.0, &
       & -0.0102, &
       & 0.0, &
       & -0.00784, &
       & 0.0, &
       & -0.00612, &
       & 0.0, &
       & -0.00500, &
       & 0.0, &
       & -0.00415, &
       & 0.0, &
       & -0.00345, &
       & 0.0, &
       & -0.00290, &
       & 0.0, &
       & -0.00252, &
       & 0.0, &
       & -0.00228, &
       & 0.0, &
       & -0.00190, &
       & 0.0, &
       & -0.00176, &
       & 0.0, &
       & -0.00154, &
       & 0.0, &
       & -0.00130, &
       & 0.0, &
       & 0.0, &
       & 0.66666, &
       & 0.0, &
       & -0.4000, &
       & 0.0, &
       & -0.0952, &
       & 0.0, &
       & -0.0444, &
       & 0.0, &
       & -0.0259, &
       & 0.0, &
       & -0.0170, &
       & 0.0, &
       & -0.0121, &
       & 0.0, &
       & -0.00904, &
       & 0.0, &
       & -0.00708, &
       & 0.0, &
       & -0.00566, &
       & 0.0, &
       & -0.00453, &
       & 0.0, &
       & -0.00385, &
       & 0.0, &
       & -0.00327, &
       & 0.0, &
       & -0.00271, &
       & 0.0, &
       & -0.00235, &
       & 0.0, &
       & -0.00204, &
       & 0.0, &
       & -0.00183, &
       & 0.0, &
       & -0.00160, &
       & 0.0, &
       & -0.00142, &
       & 0.0, &
       & -0.00134, &
       & -0.6666, &
       & 0.0, &
       & 0.93333, &
       & 0.0, &
       & -0.3619, &
       & 0.0, &
       & -0.0825, &
       & 0.0, &
       & -0.0386, &
       & 0.0, &
       & -0.0228, &
       & 0.0, &
       & -0.0152, &
       & 0.0, &
       & -0.0109, &
       & 0.0, &
       & -0.00828, &
       & 0.0, &
       & -0.00642, &
       & 0.0, &
       & -0.00519, &
       & 0.0, &
       & -0.00423, &
       & 0.0, &
       & -0.00357, &
       & 0.0, &
       & -0.00308, &
       & 0.0, &
       & -0.00254, &
       & 0.0, &
       & -0.00221, &
       & 0.0, &
       & -0.00197, &
       & 0.0, &
       & -0.00177, &
       & 0.0, &
       & -0.00158, &
       & 0.0, &
       & -0.00136, &
       & 0.0, &
       & 0.0, &
       & -0.4000, &
       & 0.0, &
       & 0.97142, &
       & 0.0, &
       & -0.3492, &
       & 0.0, &
       & -0.0767, &
       & 0.0, &
       & -0.0355, &
       & 0.0, &
       & -0.0210, &
       & 0.0, &
       & -0.0140, &
       & 0.0, &
       & -0.0100, &
       & 0.0, &
       & -0.00762, &
       & 0.0, &
       & -0.00595, &
       & 0.0, &
       & -0.00489, &
       & 0.0, &
       & -0.00395, &
       & 0.0, &
       & -0.00339, &
       & 0.0, &
       & -0.00282, &
       & 0.0, &
       & -0.00240, &
       & 0.0, &
       & -0.00214, &
       & 0.0, &
       & -0.00181, &
       & 0.0, &
       & -0.00165, &
       & 0.0, &
       & -0.00142, &
       & 0.0, &
       & -0.00131, &
       & -0.1333, &
       & 0.0, &
       & -0.3619, &
       & 0.0, &
       & 0.98412, &
       & 0.0, &
       & -0.3434, &
       & 0.0, &
       & -0.0736, &
       & 0.0, &
       & -0.0336, &
       & 0.0, &
       & -0.0197, &
       & 0.0, &
       & -0.0131, &
       & 0.0, &
       & -0.00940, &
       & 0.0, &
       & -0.00715, &
       & 0.0, &
       & -0.00565, &
       & 0.0, &
       & -0.00451, &
       & 0.0, &
       & -0.00376, &
       & 0.0, &
       & -0.00312, &
       & 0.0, &
       & -0.00278, &
       & 0.0, &
       & -0.00233, &
       & 0.0, &
       & -0.00208, &
       & 0.0, &
       & -0.00189, &
       & 0.0, &
       & -0.00169, &
       & 0.0, &
       & -0.00147, &
       & 0.0, &
       & 0.0, &
       & -0.0952, &
       & 0.0, &
       & -0.3492, &
       & 0.0, &
       & 0.98989,&
       & 0.0, &
       & -0.3403, &
       & 0.0, &
       & -0.0717, &
       & 0.0, &
       & -0.0324, &
       & 0.0, &
       & -0.0189, &
       & 0.0, &
       & -0.0126, &
       & 0.0, &
       & -0.00903, &
       & 0.0, &
       & -0.00685, &
       & 0.0, &
       & -0.00547, &
       & 0.0, &
       & -0.00432, &
       & 0.0, &
       & -0.00369, &
       & 0.0, &
       & -0.00308, &
       & 0.0, &
       & -0.00261, &
       & 0.0, &
       & -0.00227, &
       & 0.0, &
       & -0.00196, &
       & 0.0, &
       & -0.00173, &
       & 0.0, &
       & -0.00155, &
       & 0.0, &
       & -0.00139, &
       & -0.0571, &
       & 0.0, &
       & -0.0825, &
       & 0.0, &
       & -0.3434, &
       & 0.0, &
       & 0.99300,&
       & 0.0, &
       & -0.3384, &
       & 0.0, &
       & -0.0705, &
       & 0.0, &
       & -0.0316, &
       & 0.0, &
       & -0.0183, &
       & 0.0, &
       & -0.0121, &
       & 0.0, &
       & -0.00873, &
       & 0.0, &
       & -0.00667, &
       & 0.0, &
       & -0.00518, &
       & 0.0, &
       & -0.00425, &
       & 0.0, &
       & -0.00345, &
       & 0.0, &
       & -0.00291, &
       & 0.0, &
       & -0.00255, &
       & 0.0, &
       & -0.00215, &
       & 0.0, &
       & -0.00190, &
       & 0.0, &
       & -0.00168, &
       & 0.0, &
       & -0.00146, &
       & 0.0, &
       & 0.0, &
       & -0.0444, &
       & 0.0, &
       & -0.0767, &
       & 0.0, &
       & -0.3403, &
       & 0.0, &
       & 0.99487,&
       & 0.0, &
       & -0.3372, &
       & 0.0, &
       & -0.0697, &
       & 0.0, &
       & -0.0310, &
       & 0.0, &
       & -0.0179, &
       & 0.0, &
       & -0.0118, &
       & 0.0, &
       & -0.00845, &
       & 0.0, &
       & -0.00648, &
       & 0.0, &
       & -0.00501, &
       & 0.0, &
       & -0.00401, &
       & 0.0, &
       & -0.00338, &
       & 0.0, &
       & -0.00285, &
       & 0.0, &
       & -0.00243, &
       & 0.0, &
       & -0.00219, &
       & 0.0, &
       & -0.00185, &
       & 0.0, &
       & -0.00160, &
       & 0.0, &
       & -0.00140, &
       & -0.0317, &
       & 0.0, &
       & -0.0386, &
       & 0.0, &
       & -0.0736, &
       & 0.0, &
       & -0.3384, &
       & 0.0, &
       & 0.99607,&
       & 0.0, &
       & -0.3364, &
       & 0.0, &
       & -0.0691, &
       & 0.0, &
       & -0.0306, &
       & 0.0, &
       & -0.0176, &
       & 0.0, &
       & -0.0115, &
       & 0.0, &
       & -0.00826, &
       & 0.0, &
       & -0.00621, &
       & 0.0, &
       & -0.00487, &
       & 0.0, &
       & -0.00394, &
       & 0.0, &
       & -0.00322, &
       & 0.0, &
       & -0.00273, &
       & 0.0, &
       & -0.00237, &
       & 0.0, &
       & -0.00204, &
       & 0.0, &
       & -0.00177, &
       & 0.0, &
       & -0.00154, &
       & 0.0, &
       & 0.0, &
       & -0.0259, &
       & 0.0, &
       & -0.0355, &
       & 0.0, &
       & -0.0717, &
       & 0.0, &
       & -0.3372, &
       & 0.0, &
       & 0.99690,&
       & 0.0, &
       & -0.3358, &
       & 0.0, &
       & -0.0687, &
       & 0.0, &
       & -0.0303, &
       & 0.0, &
       & -0.0173, &
       & 0.0, &
       & -0.0113, &
       & 0.0, &
       & -0.00819, &
       & 0.0, &
       & -0.00617, &
       & 0.0, &
       & -0.00470, &
       & 0.0, &
       & -0.00388, &
       & 0.0, &
       & -0.00310, &
       & 0.0, &
       & -0.00267, &
       & 0.0, &
       & -0.00232, &
       & 0.0, &
       & -0.00196, &
       & 0.0, &
       & -0.00171, &
       & 0.0, &
       & -0.00156, &
       & -0.0202, &
       & 0.0, &
       & -0.0228, &
       & 0.0, &
       & -0.0336, &
       & 0.0, &
       & -0.0705, &
       & 0.0, &
       & -0.3364, &
       & 0.0, &
       & 0.99749, &
       & 0.0, &
       & -0.3354, &
       & 0.0, &
       & -0.0684, &
       & 0.0, &
       & -0.0300, &
       & 0.0, &
       & -0.0171, &
       & 0.0, &
       & -0.0112, &
       & 0.0, &
       & -0.00795, &
       & 0.0, &
       & -0.00590, &
       & 0.0, &
       & -0.00464, &
       & 0.0, &
       & -0.00376, &
       & 0.0, &
       & -0.00314, &
       & 0.0, &
       & -0.00262, &
       & 0.0, &
       & -0.00223, &
       & 0.0, &
       & -0.00190, &
       & 0.0, &
       & -0.00172, &
       & 0.0, &
       & 0.0, &
       & -0.0170, &
       & 0.0, &
       & -0.0210, &
       & 0.0, &
       & -0.0324, &
       & 0.0, &
       & -0.0697, &
       & 0.0, &
       & -0.3358, &
       & 0.0, &
       & 0.99792,&
       & 0.0, &
       & -0.3350, &
       & 0.0, &
       & -0.0681, &
       & 0.0, &
       & -0.0298, &
       & 0.0, &
       & -0.0169, &
       & 0.0, &
       & -0.0110, &
       & 0.0, &
       & -0.00788, &
       & 0.0, &
       & -0.00594, &
       & 0.0, &
       & -0.00462, &
       & 0.0, &
       & -0.00370, &
       & 0.0, &
       & -0.00309, &
       & 0.0, &
       & -0.00253, &
       & 0.0, &
       & -0.00228, &
       & 0.0, &
       & -0.00191, &
       & 0.0, &
       & -0.00165, &
       & -0.0139, &
       & 0.0, &
       & -0.0152, &
       & 0.0, &
       & -0.0197, &
       & 0.0, &
       & -0.0316, &
       & 0.0, &
       & -0.0691, &
       & 0.0, &
       & -0.3354, &
       & 0.0, &
       & 0.99826, &
       & 0.0, &
       & -0.3348, &
       & 0.0, &
       & -0.0679, &
       & 0.0, &
       & -0.0296, &
       & 0.0, &
       & -0.0168, &
       & 0.0, &
       & -0.0109, &
       & 0.0, &
       & -0.00772, &
       & 0.0, &
       & -0.00582, &
       & 0.0, &
       & -0.00456, &
       & 0.0, &
       & -0.00365, &
       & 0.0, &
       & -0.00301, &
       & 0.0, &
       & -0.00258, &
       & 0.0, &
       & -0.00219, &
       & 0.0, &
       & -0.00184, &
       & 0.0, &
       & 0.0, &
       & -0.0121, &
       & 0.0, &
       & -0.0140, &
       & 0.0, &
       & -0.0189, &
       & 0.0, &
       & -0.0310, &
       & 0.0, &
       & -0.0687, &
       & 0.0, &
       & -0.3350, &
       & 0.0, &
       & 0.99851,&
       & 0.0, &
       & -0.3346, &
       & 0.0, &
       & -0.0677, &
       & 0.0, &
       & -0.0295, &
       & 0.0, &
       & -0.0167, &
       & 0.0, &
       & -0.0108, &
       & 0.0, &
       & -0.00760, &
       & 0.0, &
       & -0.00576, &
       & 0.0, &
       & -0.00442, &
       & 0.0, &
       & -0.00367, &
       & 0.0, &
       & -0.00295, &
       & 0.0, &
       & -0.00259, &
       & 0.0, &
       & -0.00212, &
       & 0.0, &
       & -0.00189, &
       & -0.0102, &
       & 0.0, &
       & -0.0109, &
       & 0.0, &
       & -0.0131, &
       & 0.0, &
       & -0.0183, &
       & 0.0, &
       & -0.0306, &
       & 0.0, &
       & -0.0684, &
       & 0.0, &
       & -0.3348, &
       & 0.0, &
       & 0.99872, &
       & 0.0, &
       & -0.3344, &
       & 0.0, &
       & -0.0676, &
       & 0.0, &
       & -0.0294, &
       & 0.0, &
       & -0.0166, &
       & 0.0, &
       & -0.0107, &
       & 0.0, &
       & -0.00764, &
       & 0.0, &
       & -0.00561, &
       & 0.0, &
       & -0.00443, &
       & 0.0, &
       & -0.00351, &
       & 0.0, &
       & -0.00297, &
       & 0.0, &
       & -0.00242, &
       & 0.0, &
       & -0.00217, &
       & 0.0, &
       & 0.0, &
       & -0.00904, &
       & 0.0, &
       & -0.0100, &
       & 0.0, &
       & -0.0126, &
       & 0.0, &
       & -0.0179, &
       & 0.0, &
       & -0.0303, &
       & 0.0, &
       & -0.0681, &
       & 0.0, &
       & -0.3346, &
       & 0.0, &
       & 0.99888, &
       & 0.0, &
       & -0.3343, &
       & 0.0, &
       & -0.0675, &
       & 0.0, &
       & -0.0293, &
       & 0.0, &
       & -0.0165, &
       & 0.0, &
       & -0.0107, &
       & 0.0, &
       & -0.00759, &
       & 0.0, &
       & -0.00563, &
       & 0.0, &
       & -0.00437, &
       & 0.0, &
       & -0.00352, &
       & 0.0, &
       & -0.00299, &
       & 0.0, &
       & -0.00247, &
       & 0.0, &
       & -0.00200, &
       & -0.00784, &
       & 0.0, &
       & -0.00828, &
       & 0.0, &
       & -0.00940, &
       & 0.0, &
       & -0.0121, &
       & 0.0, &
       & -0.0176, &
       & 0.0, &
       & -0.0300, &
       & 0.0, &
       & -0.0679, &
       & 0.0, &
       & -0.3344, &
       & 0.0, &
       & 0.99902,&
       & 0.0, &
       & -0.3341, &
       & 0.0, &
       & -0.0674, &
       & 0.0, &
       & -0.0292, &
       & 0.0, &
       & -0.0164, &
       & 0.0, &
       & -0.0106, &
       & 0.0, &
       & -0.00751, &
       & 0.0, &
       & -0.00567, &
       & 0.0, &
       & -0.00439, &
       & 0.0, &
       & -0.00345, &
       & 0.0, &
       & -0.00284, &
       & 0.0, &
       & -0.00240, &
       & 0.0, &
       & 0.0, &
       & -0.00708, &
       & 0.0, &
       & -0.00762, &
       & 0.0, &
       & -0.00903, &
       & 0.0, &
       & -0.0118, &
       & 0.0, &
       & -0.0173, &
       & 0.0, &
       & -0.0298, &
       & 0.0, &
       & -0.0677, &
       & 0.0, &
       & -0.3343, &
       & 0.0, &
       & 0.99913, &
       & 0.0, &
       & -0.3341, &
       & 0.0, &
       & -0.0673, &
       & 0.0, &
       & -0.0291, &
       & 0.0, &
       & -0.0164, &
       & 0.0, &
       & -0.0106, &
       & 0.0, &
       & -0.00745, &
       & 0.0, &
       & -0.00559, &
       & 0.0, &
       & -0.00431, &
       & 0.0, &
       & -0.00340, &
       & 0.0, &
       & -0.00287, &
       & 0.0, &
       & -0.00237, &
       & -0.00612, &
       & 0.0, &
       & -0.00642, &
       & 0.0, &
       & -0.00715, &
       & 0.0, &
       & -0.00873, &
       & 0.0, &
       & -0.0115, &
       & 0.0, &
       & -0.0171, &
       & 0.0, &
       & -0.0296, &
       & 0.0, &
       & -0.0676, &
       & 0.0, &
       & -0.3341, &
       & 0.0, &
       & 0.99922,&
       & 0.0, &
       & -0.3340, &
       & 0.0, &
       & -0.0672, &
       & 0.0, &
       & -0.0291, &
       & 0.0, &
       & -0.0163, &
       & 0.0, &
       & -0.0105, &
       & 0.0, &
       & -0.00747, &
       & 0.0, &
       & -0.00551, &
       & 0.0, &
       & -0.00426, &
       & 0.0, &
       & -0.00343, &
       & 0.0, &
       & -0.00284, &
       & 0.0, &
       & 0.0, &
       & -0.00566, &
       & 0.0, &
       & -0.00595, &
       & 0.0, &
       & -0.00685, &
       & 0.0, &
       & -0.00845, &
       & 0.0, &
       & -0.0113, &
       & 0.0, &
       & -0.0169, &
       & 0.0, &
       & -0.0295, &
       & 0.0, &
       & -0.0675, &
       & 0.0, &
       & -0.3341, &
       & 0.0, &
       & 0.99930, &
       & 0.0, &
       & -0.3339,  &
       & 0.0, &
       & -0.0672, &
       & 0.0, &
       & -0.0290, &
       & 0.0, &
       & -0.0163, &
       & 0.0, &
       & -0.0105, &
       & 0.0, &
       & -0.00739, &
       & 0.0, &
       & -0.00546, &
       & 0.0, &
       & -0.00429, &
       & 0.0, &
       & -0.00340, &
       & 0.0, &
       & -0.00283, &
       & -0.00500, &
       & 0.0, &
       & -0.00519, &
       & 0.0, &
       & -0.00565, &
       & 0.0, &
       & -0.00667, &
       & 0.0, &
       & -0.00826, &
       & 0.0, &
       & -0.0112, &
       & 0.0, &
       & -0.0168, &
       & 0.0, &
       & -0.0294, &
       & 0.0, &
       & -0.0674, &
       & 0.0, &
       & -0.3340, &
       & 0.0, &
       & 0.99937, &
       & 0.0, &
       & -0.3339, &
       & 0.0, &
       & -0.0671, &
       & 0.0, &
       & -0.0290, &
       & 0.0, &
       & -0.0163, &
       & 0.0, &
       & -0.0105, &
       & 0.0, &
       & -0.00734, &
       & 0.0, &
       & -0.00549, &
       & 0.0, &
       & -0.00426, &
       & 0.0, &
       & -0.00339, &
       & 0.0, &
       & 0.0, &
       & -0.00453, &
       & 0.0, &
       & -0.00489, &
       & 0.0, &
       & -0.00547, &
       & 0.0, &
       & -0.00648, &
       & 0.0, &
       & -0.00819, &
       & 0.0, &
       & -0.0110, &
       & 0.0, &
       & -0.0167, &
       & 0.0, &
       & -0.0293, &
       & 0.0, &
       & -0.0673, &
       & 0.0, &
       & -0.3339, &
       & 0.0, &
       & 0.99943, &
       & 0.0, &
       & -0.3338, &
       & 0.0, &
       & -0.0671, &
       & 0.0, &
       & -0.0290, &
       & 0.0, &
       & -0.0162, &
       & 0.0, &
       & -0.0104, &
       & 0.0, &
       & -0.00737, &
       & 0.0, &
       & -0.00546, &
       & 0.0, &
       & -0.00425, &
       & 0.0, &
       & -0.00335, &
       & -0.00415, &
       & 0.0, &
       & -0.00423, &
       & 0.0, &
       & -0.00451, &
       & 0.0, &
       & -0.00518, &
       & 0.0, &
       & -0.00621, &
       & 0.0, &
       & -0.00795, &
       & 0.0, &
       & -0.0109, &
       & 0.0, &
       & -0.0166, &
       & 0.0, &
       & -0.0292, &
       & 0.0, &
       & -0.0672, &
       & 0.0, &
       & -0.3339, &
       & 0.0, &
       & 0.99948, &
       & 0.0, &
       & -0.3338, &
       & 0.0, &
       & -0.0671, &
       & 0.0, &
       & -0.0289, &
       & 0.0, &
       & -0.0162, &
       & 0.0, &
       & -0.0104, &
       & 0.0, &
       & -0.00734, &
       & 0.0, &
       & -0.00545, &
       & 0.0, &
       & -0.00412, &
       & 0.0, &
       & 0.0, &
       & -0.00385, &
       & 0.0, &
       & -0.00395, &
       & 0.0, &
       & -0.00432, &
       & 0.0, &
       & -0.00501, &
       & 0.0, &
       & -0.00617, &
       & 0.0, &
       & -0.00788, &
       & 0.0, &
       & -0.0108, &
       & 0.0, &
       & -0.0165, &
       & 0.0, &
       & -0.0291, &
       & 0.0, &
       & -0.0672, &
       & 0.0, &
       & -0.3338, &
       & 0.0, &
       & 0.99952,&
       & 0.0, &
       & -0.3337, &
       & 0.0, &
       & -0.0670, &
       & 0.0, &
       & -0.0289, &
       & 0.0, &
       & -0.0162, &
       & 0.0, &
       & -0.0104, &
       & 0.0, &
       & -0.00723, &
       & 0.0, &
       & -0.00542, &
       & 0.0, &
       & -0.00410, &
       & -0.00345, &
       & 0.0, &
       & -0.00357, &
       & 0.0, &
       & -0.00376, &
       & 0.0, &
       & -0.00425, &
       & 0.0, &
       & -0.00487, &
       & 0.0, &
       & -0.00590, &
       & 0.0, &
       & -0.00772, &
       & 0.0, &
       & -0.0107, &
       & 0.0, &
       & -0.0164, &
       & 0.0, &
       & -0.0291, &
       & 0.0, &
       & -0.0671, &
       & 0.0, &
       & -0.3338, &
       & 0.0, &
       & 0.99956, &
       & 0.0, &
       & -0.3337, &
       & 0.0, &
       & -0.0670, &
       & 0.0, &
       & -0.0289, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.00720, &
       & 0.0, &
       & -0.00530, &
       & 0.0, &
       & 0.0, &
       & -0.00327, &
       & 0.0, &
       & -0.00339, &
       & 0.0, &
       & -0.00369, &
       & 0.0, &
       & -0.00401, &
       & 0.0, &
       & -0.00470, &
       & 0.0, &
       & -0.00594, &
       & 0.0, &
       & -0.00760, &
       & 0.0, &
       & -0.0107, &
       & 0.0, &
       & -0.0164, &
       & 0.0, &
       & -0.0290, &
       & 0.0, &
       & -0.0671, &
       & 0.0, &
       & -0.3337, &
       & 0.0, &
       & 0.99959, &
       & 0.0, &
       & -0.3337,  &
       & 0.0, &
       & -0.0670, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.00728, &
       & 0.0, &
       & -0.00534, &
       & -0.00290, &
       & 0.0, &
       & -0.00308, &
       & 0.0, &
       & -0.00312, &
       & 0.0, &
       & -0.00345, &
       & 0.0, &
       & -0.00394, &
       & 0.0, &
       & -0.00464, &
       & 0.0, &
       & -0.00582, &
       & 0.0, &
       & -0.00764, &
       & 0.0, &
       & -0.0106, &
       & 0.0, &
       & -0.0163, &
       & 0.0, &
       & -0.0290, &
       & 0.0, &
       & -0.0671, &
       & 0.0, &
       & -0.3337, &
       & 0.0, &
       & 0.99963, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.00722, &
       & 0.0, &
       & 0.0, &
       & -0.00271, &
       & 0.0, &
       & -0.00282, &
       & 0.0, &
       & -0.00308, &
       & 0.0, &
       & -0.00338, &
       & 0.0, &
       & -0.00388, &
       & 0.0, &
       & -0.00462, &
       & 0.0, &
       & -0.00576, &
       & 0.0, &
       & -0.00759, &
       & 0.0, &
       & -0.0106, &
       & 0.0, &
       & -0.0163, &
       & 0.0, &
       & -0.0290, &
       & 0.0, &
       & -0.0670, &
       & 0.0, &
       & -0.3337, &
       & 0.0, &
       & 0.99965, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.00729, &
       & -0.00252, &
       & 0.0, &
       & -0.00254, &
       & 0.0, &
       & -0.00278, &
       & 0.0, &
       & -0.00291, &
       & 0.0, &
       & -0.00322, &
       & 0.0, &
       & -0.00376, &
       & 0.0, &
       & -0.00456, &
       & 0.0, &
       & -0.00561, &
       & 0.0, &
       & -0.00751, &
       & 0.0, &
       & -0.0105, &
       & 0.0, &
       & -0.0163, &
       & 0.0, &
       & -0.0289, &
       & 0.0, &
       & -0.0670, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & 0.99968, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & 0.0, &
       & -0.00235, &
       & 0.0, &
       & -0.00240, &
       & 0.0, &
       & -0.00261, &
       & 0.0, &
       & -0.00285, &
       & 0.0, &
       & -0.00310, &
       & 0.0, &
       & -0.00370, &
       & 0.0, &
       & -0.00442, &
       & 0.0, &
       & -0.00563, &
       & 0.0, &
       & -0.00745, &
       & 0.0, &
       & -0.0105, &
       & 0.0, &
       & -0.0162, &
       & 0.0, &
       & -0.0289, &
       & 0.0, &
       & -0.0670, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & 0.99970, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0103, &
       & -0.00228, &
       & 0.0, &
       & -0.00221, &
       & 0.0, &
       & -0.00233, &
       & 0.0, &
       & -0.00255, &
       & 0.0, &
       & -0.00273, &
       & 0.0, &
       & -0.00314, &
       & 0.0, &
       & -0.00365, &
       & 0.0, &
       & -0.00443, &
       & 0.0, &
       & -0.00567, &
       & 0.0, &
       & -0.00747, &
       & 0.0, &
       & -0.0105, &
       & 0.0, &
       & -0.0162, &
       & 0.0, &
       & -0.0289, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & 0.99972, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0160, &
       & 0.0, &
       & 0.0, &
       & -0.00204, &
       & 0.0, &
       & -0.00214, &
       & 0.0, &
       & -0.00227, &
       & 0.0, &
       & -0.00243, &
       & 0.0, &
       & -0.00267, &
       & 0.0, &
       & -0.00309, &
       & 0.0, &
       & -0.00367, &
       & 0.0, &
       & -0.00437, &
       & 0.0, &
       & -0.00559, &
       & 0.0, &
       & -0.00739, &
       & 0.0, &
       & -0.0104, &
       & 0.0, &
       & -0.0162, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.3336, &
       & 0.0, &
       & 0.99973, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.0287, &
       & 0.0, &
       & -0.0160, &
       & -0.00190, &
       & 0.0, &
       & -0.00197, &
       & 0.0, &
       & -0.00208, &
       & 0.0, &
       & -0.00215, &
       & 0.0, &
       & -0.00237, &
       & 0.0, &
       & -0.00262, &
       & 0.0, &
       & -0.00301, &
       & 0.0, &
       & -0.00351, &
       & 0.0, &
       & -0.00439, &
       & 0.0, &
       & -0.00551, &
       & 0.0, &
       & -0.00734, &
       & 0.0, &
       & -0.0104, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99975, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.0287, &
       & 0.0, &
       & 0.0, &
       & -0.00183, &
       & 0.0, &
       & -0.00181, &
       & 0.0, &
       & -0.00196, &
       & 0.0, &
       & -0.00219, &
       & 0.0, &
       & -0.00232, &
       & 0.0, &
       & -0.00253, &
       & 0.0, &
       & -0.00295, &
       & 0.0, &
       & -0.00352, &
       & 0.0, &
       & -0.00431, &
       & 0.0, &
       & -0.00546, &
       & 0.0, &
       & -0.00737, &
       & 0.0, &
       & -0.0104, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99977,&
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.0287, &
       & -0.00176, &
       & 0.0, &
       & -0.00177, &
       & 0.0, &
       & -0.00189, &
       & 0.0, &
       & -0.00190, &
       & 0.0, &
       & -0.00204, &
       & 0.0, &
       & -0.00223, &
       & 0.0, &
       & -0.00258, &
       & 0.0, &
       & -0.00297, &
       & 0.0, &
       & -0.00345, &
       & 0.0, &
       & -0.00426, &
       & 0.0, &
       & -0.00549, &
       & 0.0, &
       & -0.00734, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0669, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99978,&
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & 0.0, &
       & -0.00160, &
       & 0.0, &
       & -0.00165, &
       & 0.0, &
       & -0.00173, &
       & 0.0, &
       & -0.00185, &
       & 0.0, &
       & -0.00196, &
       & 0.0, &
       & -0.00228, &
       & 0.0, &
       & -0.00259, &
       & 0.0, &
       & -0.00299, &
       & 0.0, &
       & -0.00340, &
       & 0.0, &
       & -0.00429, &
       & 0.0, &
       & -0.00546, &
       & 0.0, &
       & -0.00723, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99979, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & -0.0668, &
       & -0.00154, &
       & 0.0, &
       & -0.00158, &
       & 0.0, &
       & -0.00169, &
       & 0.0, &
       & -0.00168, &
       & 0.0, &
       & -0.00177, &
       & 0.0, &
       & -0.00190, &
       & 0.0, &
       & -0.00219, &
       & 0.0, &
       & -0.00242, &
       & 0.0, &
       & -0.00284, &
       & 0.0, &
       & -0.00343, &
       & 0.0, &
       & -0.00426, &
       & 0.0, &
       & -0.00545, &
       & 0.0, &
       & -0.00720, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0288, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99980, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.0, &
       & -0.00142, &
       & 0.0, &
       & -0.00142, &
       & 0.0, &
       & -0.00155, &
       & 0.0, &
       & -0.00160, &
       & 0.0, &
       & -0.00171, &
       & 0.0, &
       & -0.00191, &
       & 0.0, &
       & -0.00212, &
       & 0.0, &
       & -0.00247, &
       & 0.0, &
       & -0.00287, &
       & 0.0, &
       & -0.00340, &
       & 0.0, &
       & -0.00425, &
       & 0.0, &
       & -0.00542, &
       & 0.0, &
       & -0.00728, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.0161, &
       & 0.0, &
       & -0.0287, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99981,&
       & 0.0, &
       & -0.3335, &
       & -0.00130, &
       & 0.0, &
       & -0.00136, &
       & 0.0, &
       & -0.00147, &
       & 0.0, &
       & -0.00146, &
       & 0.0, &
       & -0.00154, &
       & 0.0, &
       & -0.00172, &
       & 0.0, &
       & -0.00184, &
       & 0.0, &
       & -0.00217, &
       & 0.0, &
       & -0.00240, &
       & 0.0, &
       & -0.00284, &
       & 0.0, &
       & -0.00339, &
       & 0.0, &
       & -0.00412, &
       & 0.0, &
       & -0.00530, &
       & 0.0, &
       & -0.00722, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.0160, &
       & 0.0, &
       & -0.0287, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99982, &
       & 0.0, &
       & 0.0, &
       & -0.00134, &
       & 0.0, &
       & -0.00131, &
       & 0.0, &
       & -0.00139, &
       & 0.0, &
       & -0.00140, &
       & 0.0, &
       & -0.00156, &
       & 0.0, &
       & -0.00165, &
       & 0.0, &
       & -0.00189, &
       & 0.0, &
       & -0.00200, &
       & 0.0, &
       & -0.00237, &
       & 0.0, &
       & -0.00283, &
       & 0.0, &
       & -0.00335, &
       & 0.0, &
       & -0.00410, &
       & 0.0, &
       & -0.00534, &
       & 0.0, &
       & -0.00729, &
       & 0.0, &
       & -0.0103, &
       & 0.0, &
       & -0.0160, &
       & 0.0, &
       & -0.0287, &
       & 0.0, &
       & -0.0668, &
       & 0.0, &
       & -0.3335, &
       & 0.0, &
       & 0.99983 /

contains

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_int_product_sphere(sph_coeffs1, sph_coeffs2, &
       sph_nodes)
    !==========================================================================!
    ! Calculates an integral of a product of two 3D Chebyshev polynomial       !
    ! expansions over a sphere.                                                !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   coeffs1 (in):     Coefficients of the expansion of the first factor in !
    !                     the product.                                         !
    !   coeffs2 (in):     Coefficients of the expansion of the second factor in!
    !                     the product.                                         !
    !   sph_nodes (in):   The nodes of the expansion.                          !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use utils, only: utils_assert

    implicit none

    ! Arguments
    type(SPHERE_COEFFS), intent(in) :: sph_coeffs1
    type(SPHERE_COEFFS), intent(in) :: sph_coeffs2
    type(SPHERE_NODES), intent(in)  :: sph_nodes

    ! Local variables
    character(len=*), parameter :: myself = 'cheb_integrate_product_sphere'
    integer :: n_intervals, order ! Number of intervals and order of expansion
    integer :: n_stripes          ! Number of stripes in the expansion
    integer :: yi, zi             ! Indices for Y, Z
    real(kind=DP) :: xmin, xmax ! Bounds of the interval for integration along X
    real(kind=DP) :: ymin, ymax ! Bounds of the interval for integration along Y
    real(kind=DP) :: zmin, zmax ! Bounds of the interval for integration along Z
    ! Integrals over X used to compute integral over Y
    real(kind=DP) :: integrals_x(1:sph_nodes%sph_ranges%n_stripes)
    ! Integrals over Y used to compute integral over Z
    real(kind=DP) :: integrals_y(1:sph_nodes%sph_ranges%n_stripes)
    ! Coefficients for the 1D expansions performed on the fly to compute
    ! integrals over Y and Z
    real(kind=DP) :: temp_coeffs(1:sph_nodes%sph_ranges%n_stripes)

    ! ------------------------------------------------------------------------
    call utils_trace_in(myself)

    call utils_assert(sph_coeffs1%n_intervals == sph_coeffs2%n_intervals, &
         'n_intervals not compatible between sets of coefficients')
    call utils_assert(sph_coeffs1%order == sph_coeffs2%order, &
         'order not compatible between sets of coefficients')

    n_stripes = sph_nodes%sph_ranges%n_stripes
    n_intervals = sph_coeffs1%n_intervals
    order = sph_coeffs1%order
    zmin = sph_nodes%sph_ranges%zmin
    zmax = sph_nodes%sph_ranges%zmax

    do zi = 1, n_stripes
       ymin = sph_nodes%sph_ranges%ymin(zi)
       ymax = sph_nodes%sph_ranges%ymax(zi)

       do yi = 1, n_stripes
          xmin = sph_nodes%sph_ranges%xmin(yi,zi)
          xmax = sph_nodes%sph_ranges%xmax(yi,zi)

          ! Calculate integral over X for this Z, Y
          integrals_x(yi) = &
               cheb_int_product_piecewise_1D( &
               sph_coeffs1%xcoeffs(:,yi,zi), &
               sph_coeffs2%xcoeffs(:,yi,zi), &
               xmin, xmax, n_intervals, order)

       end do

       ! Generate Chebyshev expansion for integral over Y for this Z
       call cheb_expansion_piecewise_1D(temp_coeffs, integrals_x, n_intervals, &
            order)

       ! Calculate this integral over Y for this Z
       integrals_y(zi) = &
            cheb_int_piecewise_1D(temp_coeffs, ymin, ymax, n_intervals, order)

    end do

    ! Generate Chebyshev expansion for integral over Z
    call cheb_expansion_piecewise_1D(temp_coeffs, integrals_y, n_intervals, &
         order)

    ! The integral over Z is the final result
    cheb_int_product_sphere = &
         cheb_int_piecewise_1D(temp_coeffs, zmin, zmax, n_intervals, order)

    call utils_trace_out(myself)

  end function cheb_int_product_sphere
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_int_product_piecewise_1D(coeffs1, coeffs2, &
       xmin, xmax, n_intervals, order)
    !==========================================================================!
    ! Calculates an integral of a product of two piecewise, 1D Chebyshev       !
    ! polynomial expansions.                                                   !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   coeffs1 (in):     Coefficients of the expansion of the first factor in !
    !                     the product.                                         !
    !   coeffs2 (in):     Coefficients of the expansion of the second factor in!
    !                     the product.                                         !
    !   xmin (in):        The beginning of the integration interval.           !
    !   xmax (in):        The end of the integration interval.                 !
    !   n_intervals (in): The number of intervals for the expansion.           !
    !   order (in):       The order of the expansion.                          !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use utils, only: utils_assert

    implicit none

    ! Arguments
    integer, intent(in)       :: n_intervals
    integer, intent(in)       :: order
    real(kind=DP), intent(in) :: coeffs1(1:n_intervals*order)
    real(kind=DP), intent(in) :: coeffs2(1:n_intervals*order)
    real(kind=DP), intent(in) :: xmin, xmax

    ! Local variables
    integer :: i                       ! Index
    integer :: offs                    ! Index offset for current interval
    real(kind=DP) :: delta             ! Width of an interval
    real(kind=DP) :: curxmin, curxmax  ! Bounds of the current interval
    real(kind=DP) :: accum             ! Temporary
    
    !------------------------------------------------------------------------

    call utils_assert(n_intervals > 0,'n_intervals must be >0')
    call utils_assert(order > 1,'order must be >1')

    delta = (xmax - xmin)/real(n_intervals,kind=DP)
    accum = 0.0_DP
    do i=1, n_intervals
       offs = (i-1)*order
       curxmin = xmin + delta * real(i-1,kind=DP)
       curxmax = xmin + delta * real(i,kind=DP)

       accum = accum + cheb_int_product_1D(coeffs1, coeffs2, curxmin, curxmax, &
            order, offs)
    end do   

    cheb_int_product_piecewise_1D = accum

  end function cheb_int_product_piecewise_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_int_product_1D(coeffs1, coeffs2, &
       xmin, xmax, order, offs)
    !==========================================================================!
    ! Calculates an integral of a product of two single-interval, 1D Chebyshev !
    ! polynomial expansions.                                                   !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   coeffs1 (in): Coefficients of the expansion of the first factor in the !
    !                 product. If 'offs' is ommitted, these will be indexed    !
    !                 from 1. If 'offs' is specified, the indices will be      !
    !                 shifted by 'offs'. This allows for reading data from a   !
    !                 large array easily.                                      !
    !   coeffs2 (in): As coeffs1, but for the second factor in the product.    !
    !   xmin (in):   The beginning of the integration interval.                !
    !   xmax (in):   The end of the integration interval.                      !
    !   order (in):  The order of the expansion.                               !
    !   offs (in):   OPTIONAL offset in the coeffs1 and coeffs2 arrays.        !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    implicit none

    ! Arguments
    real(kind=DP), intent(in)     :: coeffs1(:)
    real(kind=DP), intent(in)     :: coeffs2(:)
    real(kind=DP), intent(in)     :: xmin, xmax
    integer, intent(in)           :: order
    integer, intent(in), optional :: offs

    ! Local variables
    integer :: n, m               ! Indices
    real(kind=DP) :: half_width   ! Half of the interval width
    real(kind=DP) :: accum        ! Temporary
    integer :: local_offs         ! Copy of optional argument, or default value

    !------------------------------------------------------------------------

    half_width = 0.5_DP * (xmax-xmin)

    if(present(offs)) then
       local_offs = offs
    else
       local_offs = 0
    end if

    ! jd: Although the integrals for mod(n+m)/=0 are zero, it's not worth
    !     checking this, it's actually faster to multiply by these zeroes.
    !     And, since it's a checkerboard pattern, there is no possibility of
    !     eliding computing or storing some of the coefficients.
    accum = 0.0_DP
    do n = 1, order
       do m = 1, order
          accum = accum + coeffs1(local_offs+n) * coeffs2(local_offs+m) * &
               cheb_product_integrals(m,n)
       end do
    end do

    cheb_int_product_1D = half_width * accum

  end function cheb_int_product_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_int_sphere(sph_coeffs, sph_nodes)
    !==========================================================================!
    ! Calculates an integral of a 3D Chebyshev expansion over a sphere.        !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   sph_coeffs (in): The coefficients of the expansion.                    !
    !   sph_nodes (in):  The nodes of the expansion.                           !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    implicit none

    ! Arguments
    type(SPHERE_COEFFS), intent(in) :: sph_coeffs
    type(SPHERE_NODES), intent(in)  :: sph_nodes

    ! Local variables
    character(len=*), parameter :: myself = 'cheb_integrate_sphere'
    integer :: n_intervals, order ! Number of intervals and order of expansion
    integer :: n_stripes          ! Number of stripes along any direction
    integer :: yi, zi             ! Indices for Y, Z
    real(kind=DP) :: xmin, xmax ! Bounds of the interval for integration along X
    real(kind=DP) :: ymin, ymax ! Bounds of the interval for integration along Y
    real(kind=DP) :: zmin, zmax ! Bounds of the interval for integration along Z
    ! Integrals over X used to compute integral over Y
    real(kind=DP) :: integrals_x(1:sph_nodes%sph_ranges%n_stripes)
    ! Integrals over Y used to compute integral over Z
    real(kind=DP) :: integrals_y(1:sph_nodes%sph_ranges%n_stripes)
    ! Coefficients for the 1D expansions performed on the fly to compute
    ! integrals over Y and Z
    real(kind=DP) :: temp_coeffs(1:sph_nodes%sph_ranges%n_stripes)

    ! ------------------------------------------------------------------------
    call utils_trace_in(myself)

    n_stripes = sph_nodes%sph_ranges%n_stripes
    n_intervals = sph_coeffs%n_intervals
    order = sph_coeffs%order
    zmin = sph_nodes%sph_ranges%zmin
    zmax = sph_nodes%sph_ranges%zmax

    do zi = 1, n_stripes
       ymin = sph_nodes%sph_ranges%ymin(zi)
       ymax = sph_nodes%sph_ranges%ymax(zi)

       do yi = 1, n_stripes
          xmin = sph_nodes%sph_ranges%xmin(yi,zi)
          xmax = sph_nodes%sph_ranges%xmax(yi,zi)

          ! Calculate integral over X for this Z, Y
          integrals_x(yi) = &
               cheb_int_piecewise_1D( &
               sph_coeffs%xcoeffs(:,yi,zi), &
               xmin, xmax, n_intervals, order)

       end do

       ! Generate Chebyshev expansion for integral over Y for this Z
       call cheb_expansion_piecewise_1D(temp_coeffs, integrals_x, &
            n_intervals, order)

       ! Calculate this integral over Y for this Z
       integrals_y(zi) = &
            cheb_int_piecewise_1D(temp_coeffs, ymin, ymax, n_intervals, order)

    end do

    ! Generate Chebyshev expansion for integral over Z
    call cheb_expansion_piecewise_1D(temp_coeffs, integrals_y, n_intervals, &
         order)

    ! The integral over Z is the final result
    cheb_int_sphere = &
         cheb_int_piecewise_1D(temp_coeffs, zmin, zmax, n_intervals, order)

    call utils_trace_out(myself)

  end function cheb_int_sphere
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_int_piecewise_1D(coeffs, xmin, xmax, &
       n_intervals, order)
    !==========================================================================!
    ! Calculates an integral of a piecewise, 1D Chebyshev expansion.           !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   coeffs (in):      Coefficients of the expansion.                       !
    !   xmin (in):        The beginning of the integration interval.           !
    !   xmax (in):        The end of the integration interval.                 !
    !   n_intervals (in): The number of intervals for the expansion.           !
    !   order (in):       The order of the expansion.                          !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use utils, only: utils_assert

    implicit none

    ! Arguments
    integer, intent(in)       :: n_intervals
    integer, intent(in)       :: order
    real(kind=DP), intent(in) :: coeffs(1:n_intervals*order)
    real(kind=DP), intent(in) :: xmin, xmax

    ! Local variables
    integer :: i                      ! index
    integer :: offs                   ! index offset for current interval
    real(kind=DP) :: delta            ! width of an interval
    real(kind=DP) :: curxmin, curxmax ! bounds of the current interval
    real(kind=DP) :: accum            ! temporary
    
    !------------------------------------------------------------------------

    call utils_assert(n_intervals > 0,'n_intervals must be >0')
    call utils_assert(order > 1,'order must be >1')

    delta = (xmax - xmin)/real(n_intervals,kind=DP)
    accum = 0.0_DP
    do i=1, n_intervals
       offs = (i-1)*order
       curxmin = xmin + delta * real(i-1,kind=DP)
       curxmax = xmin + delta * real(i,kind=DP)

       accum = accum + cheb_int_1D(coeffs, curxmin, curxmax, order, offs)
    end do   

    cheb_int_piecewise_1D = accum

  end function cheb_int_piecewise_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_int_1D(coeffs, xmin, xmax, order, offs)
    !==========================================================================!
    ! Calculates an integral of a single-interval, 1D Chebyshev expansion.     !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   coeffs (in): Coefficients of the expansion. If 'offs' is ommitted,     !
    !                these will be indexed from 1. If 'offs' is specified,     !
    !                the indices will be shifted by 'offs'. This allows for    !
    !                reading data from a large array easily.                   !
    !   xmin (in):   The beginning of the integration interval.                !
    !   xmax (in):   The end of the integration interval.                      !
    !   order (in):  The order of the expansion.                               !
    !   offs (in):   OPTIONAL offset in the coeffs array.                      !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    implicit none

    ! Arguments
    real(kind=DP), intent(in)     :: coeffs(:)
    real(kind=DP), intent(in)     :: xmin, xmax
    integer, intent(in)           :: order
    integer, intent(in), optional :: offs

    ! Local variables
    integer :: i                  ! index
    real(kind=DP) :: half_width   ! half the width of the interval
    real(kind=DP) :: accum        ! temporary
    integer :: local_offs         ! local copy of 'offs', or default if omitted

    !------------------------------------------------------------------------

    if(present(offs)) then
       local_offs = offs
    else
       local_offs = 0
    end if

    half_width = 0.5_DP * (xmax-xmin)

    ! Only every 2nd integral is nonzero, the remaining integrands are odd
    accum = 0.0_DP
    do i = 1, order, 2
       accum = accum + &
            coeffs(local_offs+i) * cheb_integrals(i)
    end do

    cheb_int_1D = half_width * accum

  end function cheb_int_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_expansion_for_sphere(sph_coeffs, sph_nodes, sph_values)
    !==========================================================================!
    ! Generates a piecewise Chebyshev polynomial expansion for a function      !
    ! defined on a sphere.                                                     !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   sph_coeffs (inout): The calculated coefficients will be returned here. !
    !                       This argument must be first allocated by passing it!
    !                       to cheb_alloc_coeffs, that's why it is (inout).    !
    !   sph_nodes (in):     The Chebyshev nodes for the sphere, obtained from  !
    !                       cheb_gen_nodes_for_sphere.                         !
    !   sph_values (in):    The values at the Chebyshev nodes.                 !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use utils, only: utils_assert

    implicit none

    ! Arguments
    type(SPHERE_COEFFS), intent(inout) :: sph_coeffs
    type(SPHERE_NODES), intent(in)     :: sph_nodes
    real(kind=DP), intent(in)          :: sph_values(:)

    ! Local variables
    character(len=*), parameter :: myself = 'cheb_expansion_for_sphere'
    integer :: yi, zi            ! Indices for Y, Z
    integer :: n_stripes         ! Number of stripes along every direction
    real(kind=DP) :: xmin, xmax  ! Bounds of the current interval along X
    integer :: base              ! Offset into sph_values

    !------------------------------------------------------------------------
    call utils_trace_in(myself)

    call utils_assert(sph_coeffs%n_intervals /= 0 .and. sph_coeffs%order /= 0, &
         "Allocate sph_coeffs with cheb_alloc_coeffs before calling " &
         //trim(myself))

    n_stripes = sph_nodes%sph_ranges%n_stripes

    call utils_assert(n_stripes == sph_coeffs%n_intervals * sph_coeffs%order, &
         "Inconsistency in "//trim(myself))

    do zi = 1, n_stripes
       do yi = 1, n_stripes

          base = 1 + (yi-1) * n_stripes + (zi-1) * n_stripes*n_stripes

          xmin = sph_nodes%sph_ranges%xmin(yi,zi)
          xmax = sph_nodes%sph_ranges%xmax(yi,zi)

          call cheb_expansion_piecewise_1D( &
               sph_coeffs%xcoeffs(:,yi,zi), &
               sph_values, sph_coeffs%n_intervals, sph_coeffs%order, base)

       end do
    end do

    call utils_trace_out(myself)

  end subroutine cheb_expansion_for_sphere
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_expansion_piecewise_1D(coeffs, values, n_intervals, order, &
       base)
    !==========================================================================!
    ! Generates a piecewise, 1D Chebyshev polynomial expansion for a list of   !
    ! function values computed at a set of Chebyshev nodes.                    !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   coeffs (out):  Here the calculated coefficients are returned.          !
    !                  The coefficients are stored as a 1D array with coeffs   !
    !                  for the first interval first, then coeffs for the second!
    !                  interval, etc. The array is always indexed from 1.      !
    !   values (in):   Values of the function to be expanded, computed at      !
    !                  Chebyshev nodes for subsequent intervals. The indices   !
    !                  are offset by 'base' (if specified), which allows the   !
    !                  values to be read from a longer array without the need  !
    !                  to create extra temporaries.                            !
    !   n_intervals (in): The number of intervals for the expansion.           !
    !   order (in):    Order of the Chebyshev expansion.                       !
    !   base (in):     OPTIONAL offset of data in 'values'. Omit if not needed.!
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use constants, only: PI
    use utils, only: utils_assert

    implicit none

    ! Arguments
    integer, intent(in)           :: n_intervals, order
    real(kind=DP), intent(out)    :: coeffs(1:n_intervals*order)
    real(kind=DP), intent(in)     :: values(:)
    integer, intent(in), optional :: base

    ! Local variables
    integer :: i                       ! Number of current interval
    integer :: offs                    ! Offset to current interval
    integer :: local_base              ! Local copy of 'base', default if absent

    !------------------------------------------------------------------------
    call utils_assert(n_intervals > 0,'n_intervals must be > 0')

    if(present(base)) then
       local_base = base
    else
       local_base = 1
    end if

    do i=1, n_intervals
       offs = (i-1)*order
       call cheb_expansion_1D(coeffs, values, order, local_base, offs)
    end do   

  end subroutine cheb_expansion_piecewise_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_expansion_1D(coeffs, values, order, base, offs)
    !==========================================================================!
    ! Generates a single-interval, 1D Chebyshev polynomial expansion for a     !
    ! list of function values computed at Chebyshev nodes.                     !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   coeffs (out):  Here the calculated coefficients are returned.          !
    !                  If 'offs' is omitted, they are written starting from an !
    !                  index of 1. If 'offs' is present, it is used to offset  !
    !                  the indices. This is useful when writing to a longer    !
    !                  array (e.g. with piecewise expansion).                  !
    !   values (in):   Values of the function to be expanded, computed at      !
    !                  Chebyshev nodes. This too is offset by 'offs', if this  !
    !                  is specified. This is useful when reading values from a !
    !                  longer array (e.g. wioth piecewise expansion).          !
    !                  The indices in values are also offset by 'base', if this!
    !                  is specified. This is useful when reading values from a !
    !                  longer array (e.g. a set of piecewise expansions).      !
    !   order (in):    Order of the Chebyshev expansion.                       !
    !   base (in):     OPTIONAL offset of data in 'values'. Omit if not needed.!
    !   offs (in):     OPTIONAL offset of data in 'values' and 'coeffs'.       !
    !                  Omit if not needed.                                     !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use constants, only: PI, DP

    implicit none

    ! Arguments
    integer, intent(in)           :: order
    real(kind=DP), intent(out)    :: coeffs(:)
    real(kind=DP), intent(in)     :: values(:)
    integer, intent(in), optional :: base
    integer, intent(in), optional :: offs

    ! Local variables
    integer :: i, k           ! indices
    integer :: local_base     ! } local copies of optional parameters,
    integer :: local_offs     ! } or default values if absent
    real(kind=DP) :: delta    ! KroneckerDelta_{i,0}
    real(kind=DP) :: ord      ! order as a real
    real(kind=DP) :: factor   ! temporary
    real(kind=DP) :: accum    ! temporary

    !------------------------------------------------------------------------

    if(present(base)) then
       local_base = base
    else
       local_base = 1
    end if

    if(present(offs)) then
       local_offs = offs
    else
       local_offs = 0
    end if

    ord = real(order,kind=DP)
    delta = 1.0_DP ! KroneckerDelta_{i,0}
    do i = 0, order-1
       factor = (2.0_DP - delta)/ord
       accum = 0.0_DP
       do k = 0, order-1
          accum = accum + &
               cos(i*PI*(k+0.5_DP)/ord) * values(local_base + local_offs + k)
       end do
       coeffs(local_offs + i+1) = factor * accum

       delta = 0.0_DP
    end do   

  end subroutine cheb_expansion_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_gen_nodes_for_sphere(sph_nodes, rad, n_intervals, order)
    !==========================================================================!
    ! Generates Chebyshev nodes for piecewise 3D integration over a sphere.    !
    ! The sphere is assumed to be centred at (0,0,0)                           !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   sph_nodes (out)  : A SPHERE_NODES variable holding the generated nodes.!
    !   rad (in)         : The radius of the sphere.                           !
    !   n_intervals (in) : Number of intervals along each Cartesian direction. !
    !   order (in)       : The order of Chebyshev expansion to use.            !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use constants, only: PI
    use utils, only: utils_alloc_check

    implicit none

    ! Arguments
    type(SPHERE_NODES), intent(out) :: sph_nodes
    real(kind=DP), intent(in) :: rad
    integer, intent(in) :: n_intervals
    integer, intent(in) :: order
    
    ! Local variables
    character(len=*), parameter :: myself = 'cheb_gen_nodes_for_sphere'
    
    integer :: n_stripes
    integer :: yi, zi            ! Indices for stripes in y, z
    real(kind=DP) :: xmin, xmax  ! Integration interval over X for current Y, Z
    real(kind=DP) :: ymin, ymax  ! Integration interval over Y for current Z
    real(kind=DP) :: zmin, zmax  ! Integration interval over Z (== [-rad,rad])
    real(kind=DP) :: rx, ry      ! Half the interval over X, Y, respectively
    real(kind=DP) :: y, z        ! Current Y, Z corresponding to yi, zi
    integer :: ierr

    !------------------------------------------------------------------------
    call utils_trace_in(myself)

    n_stripes = n_intervals * order

    allocate(sph_nodes%znodes(n_stripes),stat=ierr)
    call utils_alloc_check(myself,'znodes',ierr)
    allocate(sph_nodes%ynodes(n_stripes,n_stripes),stat=ierr)
    call utils_alloc_check(myself,'ynodes',ierr)
    allocate(sph_nodes%xnodes(n_stripes,n_stripes,n_stripes),stat=ierr)
    call utils_alloc_check(myself,'xnodes',ierr)
    allocate(sph_nodes%sph_ranges%ymin(n_stripes),stat=ierr)
    call utils_alloc_check(myself,'ymin',ierr)
    allocate(sph_nodes%sph_ranges%ymax(n_stripes),stat=ierr)
    call utils_alloc_check(myself,'ymax',ierr)
    allocate(sph_nodes%sph_ranges%xmin(n_stripes,n_stripes),stat=ierr)
    call utils_alloc_check(myself,'xmin',ierr)
    allocate(sph_nodes%sph_ranges%xmax(n_stripes,n_stripes),stat=ierr)
    call utils_alloc_check(myself,'xmax',ierr)

    zmin = -rad
    zmax = +rad

    sph_nodes%sph_ranges%n_stripes = n_stripes
    sph_nodes%sph_ranges%zmin = zmin
    sph_nodes%sph_ranges%zmax = zmax

    ! Generate Chebyshev nodes for distribution along Z
    call cheb_gen_nodes_piecewise_1D(sph_nodes%znodes, zmin, zmax, &
         n_intervals, order)

    do zi = 1, n_stripes
       z = sph_nodes%znodes(zi)

       ! Determine range in which Y changes for this Z
       ry = rad*rad - z*z
       if(ry < 0.0_DP) then
          ry = 0.0_DP ! handle rounding errors
       else
          ry = sqrt(ry)
       end if
       ymin = -ry
       ymax = +ry

       sph_nodes%sph_ranges%ymin(zi) = ymin
       sph_nodes%sph_ranges%ymax(zi) = ymax

       ! Generate Chebyshev nodes for distribution along Y for this Z
       call cheb_gen_nodes_piecewise_1D(sph_nodes%ynodes(:,zi), ymin, ymax, &
            n_intervals, order)

       do yi = 1, n_stripes
          y = sph_nodes%ynodes(yi,zi)

          ! Determine range in which X changes for this Z, Y
          rx = rad*rad - z*z - y*y
          if(rx < 0.0_DP) then
             rx = 0.0_DP ! handle rounding errors
          else
             rx = sqrt(rx)
          end if
          xmin = -rx
          xmax = +rx

          sph_nodes%sph_ranges%xmin(yi,zi) = xmin
          sph_nodes%sph_ranges%xmax(yi,zi) = xmax

          ! Generate Chebyshev nodes for distribution along X for this Z, Y
          call cheb_gen_nodes_piecewise_1D(sph_nodes%xnodes(:,yi,zi), &
               xmin, xmax, n_intervals, order)

       end do ! over Y
    end do ! over Z

    sph_nodes%n_points_total = n_stripes ** 3

    call utils_trace_out(myself)

  end subroutine cheb_gen_nodes_for_sphere
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_gen_nodes_piecewise_1D(nodes, xmin, xmax, n_intervals, &
       order)
    !==========================================================================!
    ! Calculalates the location of Chebyshev nodes of a given order, for       !
    ! a Chebyshev expansion in [xmin, xmax] on n_intervals intervals.          !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   nodes (out):      An array (order * n_intervals elements long) where   !
    !                     the nodes for every interval will be returned.       !
    !   xmin, xmax (in):  Define the range on which the interpolation will be  !
    !                     performed.                                           !
    !   n_intervals (in): The number of intervals.                             !
    !   order (in):       The order of Chebyshev interpolation.                !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use constants, only: PI

    implicit none

    ! Arguments
    integer, intent(in)        :: order
    integer, intent(in)        :: n_intervals
    real(kind=DP), intent(out) :: nodes(1:n_intervals*order)
    real(kind=DP), intent(in)  :: xmin, xmax

    ! Local variables
    integer :: i
    integer :: base           ! Shift inside nodes(:) for current interval
    real(kind=DP) :: delta    ! Width of one interval
    real(kind=DP) :: curxmin, curxmax ! xmin, xmax for current interval

    !------------------------------------------------------------------------
    delta = (xmax - xmin)/real(n_intervals,kind=DP)
    do i=1, n_intervals
       base = (i-1)*order
       curxmin = xmin + delta * real(i-1,kind=DP)
       curxmax = xmin + delta * real(i,kind=DP)

       call cheb_gen_nodes_1D(nodes(base+1:base+n_intervals), &
            curxmin,curxmax,order)
    end do   

  end subroutine cheb_gen_nodes_piecewise_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_gen_nodes_1D(nodes, xmin, xmax, order)
    !==========================================================================!
    ! Calculalates the location of Chebyshev nodes of a given order, for       !
    ! a Chebyshev expansion in [xmin, xmax].                                   !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   nodes (out):     An array ('order' elements long) where the nodes will !
    !                    be returned.                                          !
    !   xmin, xmax (in): Define the range on which the interpolation will be   !
    !                    performed.                                            !
    !   order (in)     : The order of Chebyshev interpolation.                 !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use constants, only: PI
    use utils, only: utils_assert

    implicit none

    ! Arguments
    integer, intent(in)        :: order
    real(kind=DP), intent(out) :: nodes(1:order)
    real(kind=DP), intent(in)  :: xmin, xmax

    ! Local variables
    integer :: i

    !------------------------------------------------------------------------
    call utils_assert(order > 0 .and. order <= max_cheb_order, &
         'Invalid Chebyshev expansion order.')
    
    do i=0, order-1
       nodes(i+1) = cheb_unscale_x(cos(PI*((order-1)-i+0.5_DP)/order),xmin,xmax)
    end do   

  end subroutine cheb_gen_nodes_1D
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_scale_x(x, xmin, xmax)
    !==========================================================================!
    ! Linear transformation of x in [xmin,xmax] to x' in [-1,1].               !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   x, xmin, xmax (in)                                                     !
    ! Returns:                                                                 !
    !   x'                                                                     !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    implicit none

    ! Arguments
    real(kind=DP), intent(in) :: x
    real(kind=DP), intent(in) :: xmin, xmax

    !------------------------------------------------------------------------
    cheb_scale_x = (2.0_DP*x - xmin - xmax)/(xmax - xmin)

  end function cheb_scale_x
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  real(kind=DP) function cheb_unscale_x(xprime, xmin, xmax)
    !==========================================================================!
    ! Linear transformation of x' in [-1,1] to x in [xmin,xmax].               !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   xprime, xmin, xmax (in)                                                !
    ! Returns:                                                                 !
    !   x                                                                      !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    implicit none

    ! Arguments
    real(kind=DP), intent(in) :: xprime
    real(kind=DP), intent(in) :: xmin, xmax

    !------------------------------------------------------------------------
    cheb_unscale_x = 0.5_DP*((xprime + 1.0_DP)*xmax + (1.0_DP - xprime)*xmin)

  end function cheb_unscale_x
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_alloc_coeffs(sph_coeffs, n_intervals, order)
    !==========================================================================!
    ! Allocates the storage associated with a SPHERE_COEFFS variable, sets its !
    ! 'n_intervals' and 'order' fields.                                        !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   sph_coeffs (out): The SPHERE_COEFFS variable to allocate.              !
    !   n_intervals (in): The number of intervals corresponding to sph_coeffs. !
    !   order (in):       The Chebyshev order corresponding to sph_coeffs.     !
    ! The (in) arguments are used to determine how big the storage should be.  !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use utils, only: utils_alloc_check

    implicit none

    ! Arguments
    type(SPHERE_COEFFS), intent(out)   :: sph_coeffs
    integer, intent(in)                :: n_intervals
    integer, intent(in)                :: order

    ! Local variables
    character(len=*), parameter :: myself = 'cheb_alloc_coeffs'
    integer :: n_stripes
    integer :: ierr

    !------------------------------------------------------------------------
    call utils_trace_in(myself)

    n_stripes = n_intervals * order

    allocate(sph_coeffs%xcoeffs(n_stripes,n_stripes,n_stripes), stat=ierr)
    call utils_alloc_check(myself,'sph_coeffs%xcoeffs',ierr)

    allocate(sph_coeffs%ycoeffs(n_stripes,n_stripes), stat=ierr)
    call utils_alloc_check(myself,'sph_coeffs%ycoeffs',ierr)

    allocate(sph_coeffs%zcoeffs(n_stripes), stat=ierr)
    call utils_alloc_check(myself,'sph_coeffs%zcoeffs',ierr)

    ! Set n_intervals, order -- this comes in handy in cheb_recv_coeffs
    sph_coeffs%n_intervals = n_intervals
    sph_coeffs%order = order

    call utils_trace_out(myself)
  end subroutine cheb_alloc_coeffs
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_dealloc_coeffs(sph_coeffs)
    !==========================================================================!
    ! Deallocates the storage associated with a SPHERE_COEFFS variable.        !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   sph_coeffs (inout): The SPHERE_COEFFS variable to deallocate.          !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use utils, only: utils_dealloc_check

    implicit none

    ! Arguments
    type(SPHERE_COEFFS), intent(inout)   :: sph_coeffs

    ! Local variables
    character(len=*), parameter :: myself = 'cheb_dealloc_coeffs'
    integer :: ierr

    !------------------------------------------------------------------------
    call utils_trace_in(myself)

    deallocate(sph_coeffs%xcoeffs, stat=ierr)
    call utils_dealloc_check(myself,'sph_coeffs%xcoeffs',ierr)

    deallocate(sph_coeffs%ycoeffs, stat=ierr)
    call utils_dealloc_check(myself,'sph_coeffs%ycoeffs',ierr)

    deallocate(sph_coeffs%zcoeffs, stat=ierr)
    call utils_dealloc_check(myself,'sph_coeffs%zcoeffs',ierr)

    call utils_trace_out(myself)
  end subroutine cheb_dealloc_coeffs
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_send_coeffs_initiate(handles, dest_node, coeffs, tag)
    !==========================================================================!
    ! Initiates a send of a SPHERE_COEFFS variable.                            !
    ! This calls comms_send for all the components of this derived type.       !
    ! The returned HANDLE_SET may then be tested for completion with           !
    ! cheb_test_completion.                                                    !
    !                                                                          !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   handles (out):   Here a set of handles is returned that can be used to !
    !                    test for the completion of the send, if necessary.    !
    !   dest_node (in):  The node to which the coefficents are to be sent.     !
    !   coeffs (in):     A SPHERE_COEFFS variable to be sent.                  !
    !   tag (in):        A tag for the communications.                         !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use comms, only: comms_send
    use utils, only: utils_assert

    implicit none

    ! Arguments
    type(HANDLE_SET), intent(out)   :: handles
    integer, intent(in)             :: dest_node
    type(SPHERE_COEFFS), intent(in) :: coeffs
    integer, intent(in)             :: tag

    ! Local variables
    integer :: n_stripes
    integer :: send_handles(1:n_variables_in_sphere_coeffs)

    !------------------------------------------------------------------------
    call utils_assert(coeffs%n_intervals > 0 .and. coeffs%order > 0, &
         'cheb_send_coeffs_initiate: &
         &Must first allocate the coeffs you''re sending.')

    n_stripes = coeffs%n_intervals * coeffs%order
    
    call comms_send(dest_node, coeffs%n_intervals, 1, &
         tag + CHEB_ELEMENT_TAG+1, send_handles(1), add_to_stack = .false.)
    call comms_send(dest_node, coeffs%order, 1, &
         tag + CHEB_ELEMENT_TAG+2, send_handles(2), add_to_stack = .false.)
    call comms_send(dest_node, coeffs%zcoeffs, n_stripes, &
         tag + CHEB_ELEMENT_TAG+3, send_handles(3), add_to_stack = .false.)
    call comms_send(dest_node, coeffs%ycoeffs, n_stripes**2, &
         tag + CHEB_ELEMENT_TAG+4, send_handles(4), add_to_stack = .false.)
    call comms_send(dest_node, coeffs%xcoeffs, n_stripes**3, &
         tag + CHEB_ELEMENT_TAG+5, send_handles(5), add_to_stack = .false.)

    handles%handles = send_handles
         
  end subroutine cheb_send_coeffs_initiate
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_recv_coeffs_initiate(handles, src_node, coeffs, tag)
    !==========================================================================!
    ! Initiates a receive of a SPHERE_COEFFS variable.                         !
    ! This calls comms_irecv for all the components of this derived type.      !
    ! The returned HANDLE_SET may then be tested for completion with           !
    ! cheb_test_completion.                                                    !
    !                                                                          !
    ! NB. This subroutine is expecting coeffs to have been allocated prior     !
    !     to the call, hence intent(inout).                                    !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   handles (out):  Here a set of handles is returned that can be used to  !
    !                   test for the completion of the receive.                !
    !   src_node (in):  The node from which the coefficents are to be received.!
    !   coeffs (inout): On input, a SPHERE_COEFFS variable allocated with      !
    !                   cheb_alloc_coeffs. On output: received coefficients.   !
    !   tag (in):       A tag for the communications.                          !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use comms, only: comms_irecv
    use utils, only: utils_assert

    implicit none

    ! Arguments
    type(HANDLE_SET), intent(out)      :: handles
    integer, intent(in)                :: src_node
    type(SPHERE_COEFFS), intent(inout) :: coeffs
    integer, intent(in)                :: tag

    ! Local variables
    integer :: n_stripes
    integer :: recv_handles(1:n_variables_in_sphere_coeffs)

    !------------------------------------------------------------------------
    call utils_assert(coeffs%n_intervals > 0 .and. coeffs%order > 0, &
         'cheb_recv_coeffs_initiate: &
         &Must allocate the destination coeffs first.')

    n_stripes = coeffs%n_intervals * coeffs%order
    
    call comms_irecv(src_node, coeffs%n_intervals, 1, &
         tag + CHEB_ELEMENT_TAG+1, handle = recv_handles(1))
    call comms_irecv(src_node, coeffs%order, 1, &
         tag + CHEB_ELEMENT_TAG+2, handle = recv_handles(2))
    call comms_irecv(src_node, coeffs%zcoeffs, n_stripes, &
         tag + CHEB_ELEMENT_TAG+3, handle = recv_handles(3))
    call comms_irecv(src_node, coeffs%ycoeffs, n_stripes**2, &
         tag + CHEB_ELEMENT_TAG+4, handle = recv_handles(4))
    call comms_irecv(src_node, coeffs%xcoeffs, n_stripes**3, &
         tag + CHEB_ELEMENT_TAG+5, handle = recv_handles(5))

    handles%handles = recv_handles

  end subroutine cheb_recv_coeffs_initiate
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  subroutine cheb_test_completion(complete, handles)
    !==========================================================================!
    ! Checks for the completion of a receive operation initiated with          !
    ! cheb_recv_coeffs_initiate or of a send operation initiated with          !
    ! cheb_send_coeffs_initiate.                                               !
    ! This subroutine is non-blocking.                                         !
    !--------------------------------------------------------------------------!
    ! Arguments:                                                               !
    !   complete (out): .true. iff the operation corresponding to 'handles'    !
    !                   completed.                                             !
    !   handles(in): identifies the operation in question -- use here what     !
    !                cheb_*_coeffs_initiate returned.                          !
    !--------------------------------------------------------------------------!
    ! Written by Jacek Dziedzic, January 2012                                  !
    !==========================================================================!

    use comms, only: comms_test

    implicit none

    ! Arguments
    logical, intent(out)         :: complete
    type(HANDLE_SET), intent(in) :: handles

    ! Local variables
    logical :: ready(1:n_variables_in_sphere_coeffs)
    integer :: i

    ! ------------------------------------------------------------------------

    ready(:) = .false.
    do i = 1, n_variables_in_sphere_coeffs
       call comms_test(ready(i),handles%handles(i))
    end do

    complete = all(ready)

  end subroutine cheb_test_completion
  !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

end module chebyshev_rep
